<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>M3U Редактор</title>
  
  <meta property="og:title" content="Редактировать Плейлист" />
  <meta property="og:description" content="Редактируйте, объединяйте и настраивайте порядок просмотра плейлистов для любых устройств." />
  <meta property="og:type" content="website" />
  <meta property="og:url" content="https://read24.netlify.app/" />
  <meta property="og:image" content="https://read24.netlify.app/image/icon.png" />
  <meta property="og:image:width" content="1200" />
  <meta property="og:image:height" content="630" />
  <link rel="icon" type="image/x-icon" href="https://read24.netlify.app/icon1.ico">
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    /* Добавляем стили для прокрутки категорий */
    #categoryFilter {
      max-height: 200px;
      overflow-y: auto;
      border: 1px solid #e5e7eb;
      border-radius: 0.75rem; /* rounded-xl */
      padding: 0.5rem; /* p-2 */
    }
    @keyframes fade-in {
      from { opacity: 0; transform: translateY(10px); }
      to { opacity: 1; transform: translateY(0); }
    }
    .animate-fade-in {
      animation: fade-in 0.3s ease-out;
    }
    /* CSS ДЛЯ АНИМАЦИИ ДИНАМИЧЕСКОГО ТЕКСТА */
    @keyframes text-fade-in {
      from { opacity: 0; transform: translateY(5px); }
      to { opacity: 1; transform: translateY(0); }
    }
    .dynamic-text-animated {
      animation: text-fade-in 0.4s ease-out;
    }
    /* КОНЕЦ НОВОГО CSS */

    /* НОВЫЕ СТИЛЫ ДЛЯ БЛОКА "КАК ЭТО РАБОТАЕТ" */
    @keyframes step-fade-in {
        from { opacity: 0; transform: translateY(20px); }
        to { opacity: 1; transform: translateY(0); }
    }
    .step-item {
        animation: step-fade-in 0.6s ease-out forwards;
        opacity: 0; /* Скрываем по умолчанию */
    }
    .step-item:nth-child(1) { animation-delay: 0s; }
    .step-item:nth-child(2) { animation-delay: 0.15s; }
    .step-item:nth-child(3) { animation-delay: 0.30s; }
    .step-item:nth-child(4) { animation-delay: 0.45s; }
    
    /* Стили для элемента, который можно перетаскивать (УДАЛЕНО) */
    /* .sortable-channel {
      cursor: grab;
      touch-action: none;
    } */
    
    /* Стили для обратной связи при перетаскивании (УДАЛЕНО) */
    /* .sortable-ghost {
      opacity: 0.4;
      background-color: #f3f4f6;
      border: 2px dashed #9ca3af;
      border-radius: 0.75rem;
    } */

    /* Добавляем отступ к body, чтобы контент не перекрывался фиксированной шапкой */
    body {
        padding-top: 60px; /* Высота шапки + небольшой запас */
    }

    /* [ЛОГО: ИЗМЕНЕНИЕ] - Новые стили для логотипа канала */
    .channel-logo {
        width: 32px; /* Фиксированная ширина */
        height: 32px; /* Фиксированная высота */
        object-fit: contain; /* Сохраняет пропорции и помещает целиком */
        margin-right: 0.75rem; /* ml-3 */
        border-radius: 0.25rem; /* Немного скругления */
        background-color: #ffffff; /* Белый фон, чтобы лучше смотрелось, если лого прозрачное */
        flex-shrink: 0;
    }
    .channel-item-content {
        display: flex;
        align-items: center;
        flex-grow: 1;
        min-width: 0;
    }
    /* [ЛОГО: КОНЕЦ ИЗМЕНЕНИЯ] */
    
    /* ************************************************************ */
    /* МОБИЛЬНАЯ АДАПТАЦИЯ: 24PX ДЛЯ ОСНОВНОГО ЗАГОЛОВКА */
    /* ************************************************************ */
    @media (max-width: 640px) { /* sm breakpoint по умолчанию в Tailwind */
        #heroBlock {
             /* Убираем min-h-[calc(100vh-60px)] для мобильной версии, чтобы избежать пустоты */
            min-height: auto; 
            padding-top: 2rem; /* Небольшой отступ сверху */
            padding-bottom: 2rem; /* Небольшой отступ снизу */
        }
        
        #heroBlock h1 {
            font-size: 24px; /* Устанавливаем 24px */
        }
        
      .channel-item {
        flex-direction: column;
        align-items: flex-start; 
        padding: 0.75rem 1rem; 
      }
      .channel-name {
        max-width: 100% !important; 
        margin-bottom: 0.5rem; 
        font-size: 20px; 
        font-weight: 900; 
      }
      
      /* НАСТРОЙКА КАНАЛОВ ДЛЯ АВТОРИЗОВАННОГО ПОЛЬЗОВАТЕЛЯ */
      .channel-item-content {
          width: 100%; 
          justify-content: flex-start;
          margin-bottom: 0.5rem; 
      }
      
      /* ЦЕНТРИРОВАНИЕ НАЗВАНИЯ КАНАЛА ДЛЯ ВСЕХ НА МОБИЛЬНОМ */
      /* Применяем flex-grow к .channel-name и text-align: center, чтобы центрировать его, сохраняя номер слева */
      .channel-item-content .channel-name {
          text-align: center; 
          flex-grow: 1; /* Чтобы занять пространство и центрировать */
      }

      /* [ЛОГО: ИЗМЕНЕНИЕ] На мобильном логотип справа от номера/чекбокса */
      .channel-item-content {
          /* Меняем порядок: чекбокс, номер, логотип, имя */
          display: grid;
          grid-template-columns: auto auto auto 1fr; /* Чекбокс, номер, лого, остальное */
          gap: 0.5rem;
          align-items: center;
      }
      .channel-item-content .channel-name {
          text-align: left; /* Возвращаем к левому краю */
          grid-column: 1 / 5; /* Занимает всю ширину под номером и лого */
          font-size: 16px; /* Чуть меньше */
          font-weight: 600;
          margin-top: -0.25rem; /* Поднимаем ближе */
          margin-left: 0;
          margin-bottom: 0;
      }
      .channel-logo {
          margin-right: 0;
          margin-left: 0;
          width: 24px; 
          height: 24px;
      }
      .channel-number {
          width: auto;
          margin-right: 0;
      }
      /* [ЛОГО: КОНЕЦ ИЗМЕНЕНИЯ] */
      
      /* ИМЕННОЕ ВЫРАВНИВАНИЕ ДЛЯ КНОПОК АВТОРИЗОВАННОГО ПОЛЬЗОВАТЕЛЯ (ТЕКУЩЕЕ ТРЕБОВАНИЕ) */
      .channel-buttons-container {
        display: flex; 
        flex-direction: row; 
        justify-content: space-between; 
        width: 100%; 
        align-items: center; 
      }
      .channel-buttons-container .channel-favorite-btn {
          order: -1; 
      }
      .channel-buttons-container .channel-download-btn {
          order: 0;
          margin-left: auto; 
          margin-right: auto;
      }
      .channel-buttons-container .channel-delete-btn {
          order: 1; 
          margin-left: 0;
          margin-right: 0;
      }

      /* [ПЕРЕИМЕНОВАТЬ: НОВОЕ] Стили для кнопки "Переименовать" */
      .channel-rename-btn {
          order: 2; /* Поставим ее после Удалить */
          font-size: 12px;
          padding: 4px 8px;
      }
      
      /* ПЕРЕОПРЕДЕЛЕНИЕ КНОПОК ДЛЯ НЕЗАРЕГИСТРИРОВАННОГО ПОЛЬЗОВАТЕЛЯ (ГОСТЬ) */
      /* Гость видит только кнопку "Удалить", которую нужно центрировать */
      .channel-item.guest-mode .channel-buttons-container {
          justify-content: center; /* Центрируем, так как видна только 1 кнопка */
      }
      .channel-item.guest-mode .channel-buttons-container .channel-delete-btn {
          /* Сброс/переопределение центрирования */
          margin-left: auto;
          margin-right: auto;
          order: 0; 
      }
      
      /* РЕДАКТОР: 2 РЯДА ПО 2 КНОПКИ ДЛЯ ГОСТЯ */
      #editorScreen .guest-buttons-container-mobile {
          display: grid;
          grid-template-columns: 1fr 1fr;
          gap: 0.5rem; /* gap-2 */
          width: 100%;
          margin-top: 0.5rem; /* mt-2 */
      }
      #editorScreen .guest-buttons-container-mobile button {
          width: 100%; /* Растягиваем кнопки на всю ширину ячейки */
          justify-content: center;
      }
      
      /* Стили для мобильного меню (Гамбургер) */
      #siteMenu {
          position: absolute;
          top: 56px; /* Высота шапки */
          left: 0;
          right: 0;
          background-color: white;
          padding: 1rem 0;
          box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -2px rgba(0, 0, 0, 0.1);
          flex-direction: column;
          align-items: center;
          z-index: 20;
          display: none;
      }
      #siteMenu.open {
          display: flex;
      }
      #siteMenu a {
          padding: 0.5rem 1rem;
          width: 100%;
          text-align: center;
          border-bottom: 1px solid #f3f4f6; /* gray-100 */
      }
    }
    
    /* Стили для настольной версии */
    @media (min-width: 641px) {
        #menuButton {
            display: none; /* Скрываем гамбургер на десктопе */
        }
        /* Главный контейнер шапки теперь использует flex-basis/grow для центрирования меню */
        .header-content {
            display: flex;
            width: 100%;
            justify-content: space-between;
            align-items: center;
        }
        /* Центрирование меню между лого и кнопками */
        #siteMenu {
            display: flex;
            flex-grow: 1; /* Позволяем меню занять доступное пространство */
            justify-content: center; /* Центрируем содержимое меню */
            align-items: center;
        }
        /* Для выравнивания логотипа и кнопок вправо */
        .auth-container {
            flex-shrink: 0;
            display: flex;
            align-items: center;
        }

        /* [ЛОГО: ИЗМЕНЕНИЕ] На десктопе восстанавливаем стандартное flex-выравнивание */
        .channel-item-content {
            display: flex;
            align-items: center;
            flex-grow: 1;
        }
        .channel-item-content .channel-name {
             text-align: left;
             flex-grow: 1; 
        }
        /* [ЛОГО: КОНЕЦ ИЗМЕНЕНИЯ] */
    }
    
    /* Стили для карточек сравнения */
    .comparison-card {
        /* Обновленные стили: более выраженная тень */
        flex-direction: column;
        width: 100%;
        margin-left: auto;
        margin-right: auto;
        padding: 1.5rem;
        background-color: #ffffff; /* bg-white */
        border-radius: 1rem; /* rounded-2xl */
        border-top-width: 4px;
        box-shadow: 0 10px 20px -5px rgba(0, 0, 0, 0.15), 0 4px 6px -2px rgba(0, 0, 0, 0.05); /* Усиленная тень */
        transition: transform 0.3s ease-out; /* Плавное движение при наведении */
    }
    .comparison-feature {
        /* Изменено: Используем flex-start для выравнивания текста влево */
        display: flex;
        align-items: flex-start;
        justify-content: space-between;
        color: #374151; /* text-gray-700 */
        padding-top: 0.75rem;
        padding-bottom: 0.75rem;
        border-bottom: 1px solid #f3f4f6; /* border-gray-100 */
        text-align: left; /* Текст слева */
    }
    .comparison-feature span:first-child {
        /* Текст преимущества - занимает основное место, позволяет перенос */
        text-align: left;
        max-width: 85%; /* Оставляем место для иконки справа */
        line-height: 1.5;
    }
    .comparison-feature span:last-child {
        /* Иконка - строго справа */
        flex-shrink: 0;
        margin-left: 0.5rem;
    }

    /* Анимация появления для всего блока сравнения (для примера) */
    @keyframes card-slide-in {
        from { opacity: 0; transform: translateY(30px); }
        to { opacity: 1; transform: translateY(0); }
    }
    #comparisonBlock .comparison-card:first-child {
        animation: card-slide-in 0.6s ease-out forwards;
    }
    #comparisonBlock .comparison-card:last-child {
        animation: card-slide-in 0.6s ease-out 0.2s forwards; /* Задержка для второй карточки */
    }
    
    /* Стили для FAQ (Аккордеон) */
    .faq-item {
        border-bottom: 1px solid #e5e7eb;
        cursor: pointer;
    }
    .faq-question {
        font-weight: 600;
        color: #1f2937;
        padding: 1rem 0;
        display: flex;
        justify-content: space-between;
        align-items: center;
        transition: color 0.2s ease-in-out; /* Анимация цвета */
        
        /* Добавление иконки "вниз" по умолчанию */
        background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='16' height='16' viewBox='0 0 24 24' fill='none' stroke='%234b5563' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpolyline points='6 9 12 15 18 9'%3E%3C/polyline%3E%3C/svg%3E");
        background-repeat: no-repeat;
        background-position: right center;
        padding-right: 2rem; /* Отступ для иконки */
    }
    .faq-question:hover {
        color: #ef4444; /* red-500 */
    }

    /* Активное состояние вопроса: текст красный и иконка "вверх" */
    .faq-item[aria-expanded="true"] .faq-question {
        color: #ef4444; /* red-500 */
        background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='16' height='16' viewBox='0 0 24 24' fill='none' stroke='%23ef4444' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpolyline points='18 15 12 9 6 15'%3E%3C/polyline%3E%3C/svg%3E");
    }

    .faq-answer {
        padding-bottom: 0rem;
        padding-top: 0rem;
        color: #4b5563;
        max-height: 0;
        overflow: hidden;
        transition: max-height 0.3s ease-out, padding 0.3s ease-out;
    }
    .faq-item[aria-expanded="true"] .faq-answer {
        max-height: 300px; /* Достаточно для плавного открытия */
        padding-bottom: 1rem;
    }
    
    /* Стили для Базы знаний */
    .article-card {
        transition: transform 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
    }
    .article-card:hover {
        transform: translateY(-5px);
        box-shadow: 0 15px 25px -5px rgba(239, 68, 68, 0.15); /* red-500 shadow */
    }
    
    /* Стили для картинок в сравнении */
    .comparison-icon {
        width: 1.5rem; /* h-6 */
        height: 1.5rem; /* w-6 */
        object-fit: contain;
    }

    /* СТИЛЫ ДЛЯ КВАДРАТНОГО МОДАЛЬНОГО ОКНА РЕГИСТРАЦИИ */
    .square-modal-content {
        aspect-ratio: 1 / 1; /* Делаем окно квадратным */
        max-width: 400px;
        width: 90%;
        padding: 1.5rem;
        position: relative; /* Для позиционирования кнопки закрытия */
        display: flex;
        flex-direction: column;
        justify-content: center; /* Центрируем контент */
        align-items: center;
    }
    
    /* СТИЛЫ ДЛЯ ЛОГОТИПА */
    .logo-link img {
        transition: transform 0.2s ease-in-out;
    }
    .logo-link:hover img {
        transform: scale(1.2); /* Увеличение на 20% при наведении */
    }
    /* Стили для нумерации в списке */
    .channel-number {
        font-weight: 700;
        color: #ef4444; /* red-500 */
        margin-right: 0.75rem;
        width: 30px; /* ИЗМЕНЕНО: Фиксированная ширина для 1000+ каналов */
        text-align: right;
        flex-shrink: 0;
    }
    /* .channel-item-content { // Дублировано выше с изменениями для мобильного
        display: flex;
        align-items: center;
        flex-grow: 1;
        min-width: 0; 
    } */
    /* Стили для сокращения названия канала многоточием */
    .channel-name {
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
        min-width: 50px; /* Минимальная ширина, чтобы текст не исчезал */
        flex-grow: 1;
        /* [ЛОГО: ИЗМЕНЕНИЕ] */
        max-width: 100%; /* Убедиться, что не выходит за пределы */
        /* [ЛОГО: КОНЕЦ ИЗМЕНЕНИЯ] */
    }
    /* Стили для чекбокса */
    .channel-checkbox {
        margin-right: 0.75rem;
        flex-shrink: 0;
    }

  </style>
</head>
<body class="bg-white text-black min-h-screen flex items-center justify-center px-4">

  <header id="siteHeader" class="fixed top-0 left-0 w-full bg-white shadow-md z-30">
    <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 h-14 flex justify-between items-center header-content">
      
      <a href="/" class="flex items-center space-x-2 flex-shrink-0 logo-link">
        <img src="https://read24.netlify.app/icon1.ico" alt="Логотип" class="h-8 w-8">
        <span class="text-xl font-bold text-gray-800 hidden sm:inline"></span>
      </a>

      <nav id="siteMenu" class="hidden sm:flex space-x-6">
        <a href="#whyUsBlock" class="menu-link text-gray-600 hover:text-red-600 transition">Преимущества</a>
        <a href="#howItWorksBlock" class="menu-link text-gray-600 hover:text-red-600 transition">Как редактировать</a>
        <a href="#comparisonBlock" class="menu-link text-gray-600 hover:text-red-600 transition">Сравнение</a>
        <a href="#faqBlock" class="menu-link text-gray-600 hover:text-red-600 transition">Частые вопросы</a>
        <a href="https://read24.netlify.app/logo" id="freePlaylistsLink" class="menu-link text-gray-600 hover:text-red-600 transition">Логотипы</a>
        <a href="#knowledgeBaseBlock" id="knowledgeBaseLink" class="menu-link text-gray-600 hover:text-red-600 transition">База знаний</a>
        </nav>

      <div class="flex items-center space-x-4 auth-container flex-shrink-0">
        
        <button id="openRegisterModalBtnHeader" 
            class="bg-black text-white text-sm font-semibold px-4 py-2 rounded-xl shadow-md hover:bg-gray-900 transition">
            ВОЙТИ / РЕГИСТРАЦИЯ
        </button>

        <button id="logoutBtn"
          class="bg-red-600 text-white text-sm font-semibold px-4 py-2 rounded-xl shadow-md hover:bg-red-700 transition hidden">
          ВЫЙТИ
        </button>

        <button id="menuButton" class="sm:hidden text-gray-600 hover:text-red-600 transition p-2">
            <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16m-7 6h7"></path>
            </svg>
        </button>
      </div>
    </div>
  </header>
  
  <div id="mainScreen" class="text-center w-full max-w-6xl"> 
    
    <div id="heroBlock" class="animate-fade-in mb-8 w-full max-w-4xl mx-auto flex flex-col items-center justify-center min-h-[calc(100vh-60px)]"> 
        <h1 class="text-3xl sm:text-5xl font-extrabold text-gray-800 leading-tight mb-8 max-w-4xl mx-auto">
            <span class="block">Редактируйте любые плейлисты</span>
            <span class="block">
                <span id="staticTitlePart" class="text-gray-800">для </span>
                <span id="dynamicTitlePart" class="text-red-600">полного контроля</span><span class="text-red-600">.</span>
            </span>
        </h1>
        <p class="text-base sm:text-lg text-gray-600 mb-10 max-w-2xl mx-auto">
            Получите полный контроль над вашими медиатеками, объединяя
            источники и настраивая порядок просмотра.
        </p>
        <button id="goToWhyUsBtn"
            class="bg-red-600 text-white text-lg font-semibold px-10 py-3 rounded-2xl shadow-xl hover:bg-red-700 transition transform hover:scale-105">
            Начать редактирование
        </button>
    </div>
    
    <div id="whyUsBlock" class="w-full max-w-7xl mx-auto py-10 px-4 sm:px-6 lg:px-8 flex flex-col items-center justify-center min-h-[calc(100vh-60px)]">
        <span class="text-red-600 font-bold text-sm uppercase tracking-wider block mb-2">ПОЧЕМУ МЫ?</span>
        <h2 class="text-2xl sm:text-4xl font-extrabold text-gray-800 mb-10">
            Возможности для ваших плейлистов
        </h2>

        <div class="flex flex-wrap justify-center gap-6">
            
            <div class="w-full sm:w-80 p-6 bg-white rounded-2xl shadow-xl flex flex-col items-center text-center transition hover:shadow-2xl">
                <div class="text-red-600 text-4xl mb-4">
                    <img src="https://read24.netlify.app/image/approved.png" alt="Полный контроль" class="w-10 h-10 mx-auto" />
                </div>
                <h3 class="text-xl font-bold text-gray-800 mb-3">Полный контроль</h3>
                <p class="text-gray-600 text-sm">
                    Настраивайте порядок воспроизведения, удаляйте ненужное и добавляйте новый контент в вашу библиотеку за секунды.
                </p>
            </div>

            <div class="w-full sm:w-80 p-6 bg-white rounded-2xl shadow-xl flex flex-col items-center text-center transition hover:shadow-2xl">
                <div class="text-red-600 text-4xl mb-4">
                    <img src="https://read24.netlify.app/image/views.png" alt="Просмотр без границ" class="w-10 h-10 mx-auto" />
                </div>
                <h3 class="text-xl font-bold text-gray-800 mb-3">Просмотр без границ</h3>
                <p class="text-gray-600 text-sm">
                    Смотрите ваши плейлисты на любом устройстве: от мобильного телефона до Smart TV. Всегда синхронизировано.
                </p>
            </div>

            <div class="w-full sm:w-80 p-6 bg-white rounded-2xl shadow-xl flex flex-col items-center text-center transition hover:shadow-2xl">
                <div class="text-red-600 text-4xl mb-4">
                    <img src="https://read24.netlify.app/image/library.png" alt="Единая библиотека" class="w-10 h-10 mx-auto" />
                </div>
                <h3 class="text-xl font-bold text-gray-800 mb-3">Единая библиотека</h3>
                <p class="text-gray-600 text-sm">
                    Объединяйте медиафайлы из разных источников в одно централизованное и удобное место для доступа.
                </p>
            </div>
        </div>
        
        <button id="startEditingBtn"
            class="bg-red-600 text-white text-lg font-semibold px-10 py-3 rounded-2xl shadow-xl hover:bg-red-700 transition transform hover:scale-105 mt-10">
            Начать редактирование
        </button>
    </div>

    <div id="howItWorksBlock" class="w-full max-w-7xl mx-auto py-10 px-4 sm:px-6 lg:px-8 flex flex-col items-center justify-center min-h-[calc(100vh-60px)]">
        <span class="text-red-600 font-bold text-sm uppercase tracking-wider block mb-2">КАК ЭТО РАБОТАЕТ</span>
        <h2 class="text-2xl sm:text-4xl font-extrabold text-gray-800 mb-12">
            Процесс Редактирования: Начните за 4 Шага
        </h2>

        <div class="grid grid-cols-1 md:grid-cols-4 gap-8 max-w-6xl mx-auto relative">
            
            <div class="hidden md:block absolute top-1/4 bottom-1/4 left-0 right-0 h-1 bg-gray-200 mx-10"></div>

            <div class="step-item flex flex-col items-center text-center relative z-10">
                <div class="w-20 h-20 bg-red-600 text-white font-black rounded-full flex items-center justify-center text-3xl mb-4 ring-4 ring-red-200">1</div>
                <h3 class="text-xl font-extrabold text-gray-800 mb-2">Регистрация</h3>
                <p class="text-gray-600 text-sm">
                    Быстро создайте личный кабинет, чтобы получить доступ ко всем инструментам редактирования и облачному хранилищу.
                </p>
                <div class="md:hidden h-10 w-1 bg-gray-200 mt-4"></div>
            </div>

            <div class="step-item flex flex-col items-center text-center relative z-10">
                <div class="w-20 h-20 bg-red-600 text-white font-black rounded-full flex items-center justify-center text-3xl mb-4 ring-4 ring-red-200">2</div>
                <h3 class="text-xl font-extrabold text-gray-800 mb-2">Загрузите плейлист</h3>
                <p class="text-gray-600 text-sm">
                    Импортируйте файл .m3u, .m3u8, или другой поддерживаемый формат, используя прямую ссылку или загрузку с устройства.
                </p>
                <div class="md:hidden h-10 w-1 bg-gray-200 mt-4"></div>
            </div>

            <div class="step-item flex flex-col items-center text-center relative z-10">
                <div class="w-20 h-20 bg-red-600 text-white font-black rounded-full flex items-center justify-center text-3xl mb-4 ring-4 ring-red-200">3</div>
                <h3 class="text-xl font-extrabold text-gray-800 mb-2">Отредактируйте список</h3>
                <p class="text-gray-600 text-sm">
                    Используйте удобный интерфейс для изменения порядка, удаления или добавления новых каналов/ссылок.
                </p>
                <div class="md:hidden h-10 w-1 bg-gray-200 mt-4"></div>
            </div>

            <div class="step-item flex flex-col items-center text-center relative z-10">
                <div class="w-20 h-20 bg-red-600 text-white font-black rounded-full flex items-center justify-center text-3xl mb-4 ring-4 ring-red-200">4</div>
                <h3 class="text-xl font-extrabold text-gray-800 mb-2">Сохраните и используйте</h3>
                <p class="text-gray-600 text-sm">
                    Сохраните изменения. Вы получите новую ссылку, которая будет автоматически обновляться, или скачаете готовый файл.
                </p>
                </div>
        </div>
    </div>
    
    <div id="comparisonBlock" class="w-full max-w-7xl mx-auto py-10 px-4 sm:px-6 lg:px-8 flex flex-col items-center justify-center min-h-[calc(100vh-60px)] bg-white">
        <span class="text-red-600 font-bold text-sm uppercase tracking-wider block mb-2">ВЫБЕРИТЕ СВОЙ ПУТЬ</span>
        <h2 class="text-2xl sm:text-4xl font-extrabold text-gray-800 mb-10">
            Сравнение Доступов: С регистрацией vs Без нее
        </h2>

        <div class="flex flex-col lg:flex-row gap-8 w-full max-w-4xl">
            
            <div class="comparison-card border-gray-400">
                <h3 class="text-2xl font-bold text-gray-800 mb-2 text-left">Без регистрации</h3>
                <p class="text-sm text-gray-500 mb-6 text-left">Базовые возможности для быстрого редактирования.</p>

                <div class="flex-grow">
                    <div class="comparison-feature">
                        <span>Единоразовое редактирование плейлиста</span>
                        <span><img src="https://read24.netlify.app/image/1.png" alt="Доступно" class="comparison-icon" /></span>
                    </div>
                    <div class="comparison-feature">
                        <span>Сохранение плейлиста в облаке</span>
                        <span><img src="https://read24.netlify.app/image/2.png" alt="Недоступно" class="comparison-icon" /></span>
                    </div>
                    <div class="comparison-feature">
                        <span>Динамическая ссылка на плейлист (автообновление)</span>
                        <span><img src="https://read24.netlify.app/image/2.png" alt="Недоступно" class="comparison-icon" /></span>
                    </div>
                    <div class="comparison-feature">
                        <span>Доступ к истории изменений</span>
                        <span><img src="https://read24.netlify.app/image/2.png" alt="Недоступно" class="comparison-icon" /></span>
                    </div>
                    <div class="comparison-feature border-none">
                        <span>Синхронизация между устройствами</span>
                        <span><img src="https://read24.netlify.app/image/2.png" alt="Недоступно" class="comparison-icon" /></span>
                    </div>
                </div>

                <button class="w-full bg-gray-300 text-gray-800 text-lg font-semibold px-4 py-3 rounded-xl shadow-lg mt-6 hover:bg-gray-400 transition" id="startNoRegBtn">
                    Начать редактирование
                </button>
            </div>

            <div class="comparison-card border-red-600">
                <h3 class="text-2xl font-bold text-red-600 mb-2 text-left">С регистрацией</h3>
                <p class="text-sm text-gray-500 mb-6 text-left">Полный доступ ко всем функциям и облаку.</p>

                <div class="flex-grow">
                    <div class="comparison-feature">
                        <span>Единоразовое редактирование плейлиста</span>
                        <span><img src="https://read24.netlify.app/image/1.png" alt="Доступно" class="comparison-icon" /></span>
                    </div>
                    <div class="comparison-feature">
                        <span>Сохранение плейлиста в облаке</span>
                        <span><img src="https://read24.netlify.app/image/1.png" alt="Доступно" class="comparison-icon" /></span>
                    </div>
                    <div class="comparison-feature">
                        <span>Динамическая ссылка на плейлист (автообновление)</span>
                        <span><img src="https://read24.netlify.app/image/1.png" alt="Доступно" class="comparison-icon" /></span>
                    </div>
                    <div class="comparison-feature">
                        <span>Доступ к истории изменений</span>
                        <span><img src="https://read24.netlify.app/image/1.png" alt="Доступно" class="comparison-icon" /></span>
                    </div>
                    <div class="comparison-feature border-none">
                        <span>Синхронизация между устройствами</span>
                        <span><img src="https://read24.netlify.app/image/1.png" alt="Доступно" class="comparison-icon" /></span>
                    </div>
                </div>

                <button id="registerNowCardBtn" class="w-full bg-red-600 text-white text-lg font-semibold px-4 py-3 rounded-xl shadow-lg mt-6 hover:bg-red-700 transition transform hover:scale-105">
                    Регистрация
                </button>
            </div>
        </div>

        <p class="text-gray-600 text-sm mt-10 max-w-xl">
            Для получения максимального удобства и доступа ко всем продвинутым функциям редактирования плейлистов, рекомендуем пройти **"быструю регистрацию"**.
        </p>
    </div>
    
    <div id="faqBlock" class="w-full max-w-7xl mx-auto py-10 px-4 sm:px-6 lg:px-8 flex flex-col items-center justify-center min-h-[calc(100vh-60px)]">
        <span class="text-red-600 font-bold text-sm uppercase tracking-wider block mb-2">СПРОСИТЕ НАС</span>
        <h2 class="text-2xl sm:text-4xl font-extrabold text-gray-800 mb-10">
            Частые вопросы
        </h2>

        <div class="w-full max-w-2xl text-left border-t border-gray-200">
            
            <div class="faq-item" tabindex="0" aria-expanded="false">
                <div class="faq-question" onclick="toggleFaq(this.parentElement)">
                    Какие форматы плейлистов поддерживает ваш редактор?
                </div>
                <div class="faq-answer">
                    <p>
                        Импортируйте файлы в форматах **.m3u**, **.m3u8**, или **других поддерживаемых форматах**, используя прямую ссылку или загрузку с устройства.
                    </p>
                </div>
            </div>

            <div class="faq-item" tabindex="0" aria-expanded="false">
                <div class="faq-question" onclick="toggleFaq(this.parentElement)">
                    Могу ли я объединить несколько плейлистов в один?
                </div>
                <div class="faq-answer">
                    <p>
                        Да, это одна из ключевых возможностей нашего сервиса! Вы можете легко импортировать несколько файлов или ссылок, а затем объединить их в одну централизованную библиотеку.
                    </p>
                </div>
            </div>

            <div class="faq-item" tabindex="0" aria-expanded="false">
                <div class="faq-question" onclick="toggleFaq(this.parentElement)">
                    Что такое "Динамическая ссылка на плейлист" и как она работает?
                </div>
                <div class="faq-answer">
                    <p>
                        Динамическая ссылка (доступна после регистрации) — это постоянный URL вашего плейлиста. Когда вы вносите изменения в список через наш редактор, плейлист по этой ссылке **"автоматически обновляется"** на всех ваших устройствах (Smart TV, плееры и т.д.).
                    </p>
                </div>
            </div>

            <div class="faq-item" tabindex="0" aria-expanded="false">
                <div class="faq-question" onclick="toggleFaq(this.parentElement)">
                    Безопасно ли загружать мой плейлист?
                </div>
                <div class="faq-answer">
                    <p>
                        Абсолютно. Мы гарантируем полную конфиденциальность и не храним личные данные или содержимое ваших плейлистов, если вы сами не решите сохранить их в личном кабинете. Даже в этом случае они защищены.
                    </p>
                </div>
            </div>

            <div class="faq-item" tabindex="0" aria-expanded="false">
                <div class="faq-question" onclick="toggleFaq(this.parentElement)">
                    Могу ли я изменить порядок каналов/ссылок?
                </div>
                <div class="faq-answer">
                    <p>
                        Да. Наш редактор имеет интуитивно понятный интерфейс **для изменения порядка** элементов в списке простым движением.
                    </p>
                </div>
            </div>
            
            <div class="faq-item" tabindex="0" aria-expanded="false">
                <div class="faq-question" onclick="toggleFaq(this.parentElement)">
                    Нужно ли регистрироваться, чтобы отредактировать один плейлист?
                </div>
                <div class="faq-answer">
                    <p>
                        Нет, для **"единоразового редактирования"** и скачивания файла регистрация не требуется. Однако, чтобы сохранить плейлисты в облаке и получить динамическую ссылку для автообновления, регистрация необходима.
                    </p>
                </div>
            </div>
            
            <div class="faq-item" tabindex="0" aria-expanded="false">
                <div class="faq-question" onclick="toggleFaq(this.parentElement)">
                    Работает ли ваш редактор на мобильных устройствах?
                </div>
                <div class="faq-answer">
                    <p>
                        Да, наш сервис полностью адаптирован и корректно работает на всех современных устройствах, включая смартфоны, планшеты и настольные компьютеры.
                    </p>
                </div>
            </div>
        </div>
    </div>
    
    <div id="knowledgeBaseBlock" class="w-full max-w-7xl mx-auto py-10 px-4 sm:px-6 lg:px-8 flex flex-col items-center min-h-[calc(100vh-60px)]">
        <span class="text-red-600 font-bold text-sm uppercase tracking-wider block mb-2">ПОЛЕЗНАЯ ИНФОРМАЦИЯ</span>
        <h2 class="text-2xl sm:text-4xl font-extrabold text-gray-800 mb-10">
            База знаний IPTV и Плейлистов
        </h2>
        
        <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6 w-full max-w-6xl text-left">
            
            <a href="#" class="article-card block bg-white p-6 rounded-xl shadow-lg border border-gray-100">
                <h3 class="text-xl font-bold text-gray-800 mb-2 hover:text-red-600 transition">Что такое IPTV и как оно работает?</h3>
                <p class="text-gray-600 text-sm">Подробное объяснение технологии Internet Protocol Television, ее преимуществ перед кабельным ТВ и принципов работы.</p>
                <span class="text-xs text-red-500 font-semibold mt-3 block">#IPTV_База</span>
            </a>

            <a href="#" class="article-card block bg-white p-6 rounded-xl shadow-lg border border-gray-100">
                <h3 class="text-xl font-bold text-gray-800 mb-2 hover:text-red-600 transition">Форматы плейлистов M3U и M3U8: различия и использование.</h3>
                <p class="text-gray-600 text-sm">Разбор двух наиболее популярных форматов плейлистов, включая их структуру и расширения, такие как #EXTINF.</p>
                <span class="text-xs text-red-500 font-semibold mt-3 block">#M3U_Гайд</span>
            </a>

            <a href="#" class="article-card block bg-white p-6 rounded-xl shadow-lg border border-gray-100">
                <h3 class="text-xl font-bold text-gray-800 mb-2 hover:text-red-600 transition">Как выбрать лучший IPTV-плеер для вашего устройства.</h3>
                <p class="text-gray-600 text-sm">Обзор и сравнение популярных приложений для Smart TV, Android, iOS и ПК, поддерживающих плейлисты M3U.</p>
                <span class="text-xs text-red-500 font-semibold mt-3 block">#Плееры_Обзор</span>
            </a>

            <a href="#" class="article-card block bg-white p-6 rounded-xl shadow-lg border border-gray-100">
                <h3 class="text-xl font-bold text-gray-800 mb-2 hover:text-red-600 transition">Решение проблем: почему плейлист не загружается или каналы не работают.</h3>
                <p class="text-gray-600 text-sm">Пошаговое руководство по диагностике и исправлению распространенных ошибок, связанных с нерабочими ссылками и блокировками.</p>
                <span class="text-xs text-red-500 font-semibold mt-3 block">#Troubleshooting</span>
            </a>

            <a href="#" class="article-card block bg-white p-6 rounded-xl shadow-lg border border-gray-100">
                <h3 class="text-xl font-bold text-gray-800 mb-2 hover:text-red-600 transition">Структура IPTV плейлиста: #EXTINF и атрибуты group-title.</h3>
                <p class="text-gray-600 text-sm">Углубленное изучение обязательных и необязательных тегов в плейлисте, влияющих на сортировку и отображение категорий.</p>
                <span class="text-xs text-red-500 font-semibold mt-3 block">#EXTINF_Секреты</span>
            </a>

            <a href="#" class="article-card block bg-white p-6 rounded-xl shadow-lg border border-gray-100">
                <h3 class="text-xl font-bold text-gray-800 mb-2 hover:text-red-600 transition">Как объединить плейлисты из разных источников в один.</h3>
                <p class="text-gray-600 text-sm">Практический гайд по консолидации нескольких M3U файлов для создания единой, упорядоченной медиатеки.</p>
                <span class="text-xs text-red-500 font-semibold mt-3 block">#Слияние_Гайд</span>
            </a>
            
            <a href="#" class="article-card block bg-white p-6 rounded-xl shadow-lg border border-gray-100">
                <h3 class="text-xl font-bold text-gray-800 mb-2 hover:text-red-600 transition">Что такое динамическая ссылка на плейлист и почему она удобна.</h3>
                <p class="text-gray-600 text-sm">Объяснение преимущества постоянного URL, который автоматически обновляется при редактировании плейлиста на сервере.</p>
                <span class="text-xs text-red-500 font-semibold mt-3 block">#Динамика</span>
            </a>
            
            <a href="#" class="article-card block bg-white p-6 rounded-xl shadow-lg border border-gray-100">
                <h3 class="text-xl font-bold text-gray-800 mb-2 hover:text-red-600 transition">Синхронизация IPTV на разных устройствах: пошаговая инструкция.</h3>
                <p class="text-gray-600 text-sm">Как обеспечить бесшовный просмотр любимых каналов и настроек на телефоне, планшете и Smart TV.</p>
                <span class="text-xs text-red-500 font-semibold mt-3 block">#Синхронизация</span>
            </a>

            <a href="#" class="article-card block bg-white p-6 rounded-xl shadow-lg border border-gray-100">
                <h3 class="text-xl font-bold text-gray-800 mb-2 hover:text-red-600 transition">Как удалять дубликаты каналов в плейлисте и зачем это нужно.</h3>
                <p class="text-gray-600 text-sm">Советы по очистке плейлиста от повторяющихся ссылок для повышения стабильности и удобства использования.</p>
                <span class="text-xs text-red-500 font-semibold mt-3 block">#Очистка_Дубликатов</span>
            </a>
            
            <a href="#" class="article-card block bg-white p-6 rounded-xl shadow-lg border border-gray-100">
                <h3 class="text-xl font-bold text-gray-800 mb-2 hover:text-red-600 transition">Облачное хранение плейлистов: преимущества и безопасность.</h3>
                <p class="text-gray-600 text-sm">Почему хранить плейлисты онлайн удобнее, чем локально, и как обеспечить безопасность ваших данных.</p>
                <span class="text-xs text-red-500 font-semibold mt-3 block">#Облако_Безопасность</span>
            </a>
            
        </div>
    </div>
    <div id="unauthenticatedMessage" class="hidden"></div>
    <div id="authButtonContainer" class="hidden"></div>

    <input type="file" id="fileInput" accept="*/*" class="hidden" multiple>
    
    <div id="loading" class="hidden text-blue-600 mb-4">
      <div class="animate-spin rounded-full h-6 w-6 border-b-2 border-blue-600 mx-auto mb-2"></div>
      Загрузка файла...
    </div>

  </div>

  <div id="editorScreen" class="hidden w-full max-w-7xl mx-auto py-6 px-4">
    <div class="flex flex-col sm:flex-row justify-center sm:justify-between items-center mb-4">
      <h1 class="text-xl font-bold text-gray-800 text-center sm:text-left">
        РЕДАКТОР КАНАЛОВ
        <span id="editorChannelCounter" class="text-2xl font-extrabold text-red-600 ml-2">
           (0)
        </span>
      </h1>
      
      <div id="editorButtonsContainer" 
          class="flex gap-2 w-full sm:w-auto justify-center sm:justify-end mt-2 sm:mt-0 
                 md:flex-row md:space-x-2 md:w-auto 
                 flex-wrap sm:flex-nowrap">
          
        <button id="openUploadModalBtn"
          class="bg-blue-600 text-white px-5 py-2 rounded-xl hover:bg-blue-700 transition text-sm sm:text-base">
          ЗАГРУЗИТЬ ПЛЕЙЛИСТ
        </button>
        <button id="addChannelBtn"
          class="bg-green-600 text-white px-5 py-2 rounded-xl hover:bg-green-700 transition text-sm sm:text-base">
          ДОБАВИТЬ КАНАЛ
        </button>
        <button id="removeDuplicatesBtn"
          class="bg-red-600 text-white px-5 py-2 rounded-xl hover:bg-red-700 transition text-sm sm:text-base">
          УДАЛИТЬ ДУБЛИ
        </button>
        <button id="revertBtn"
          class="bg-yellow-600 text-white px-5 py-2 rounded-xl hover:bg-yellow-700 transition text-sm sm:text-base hidden">
          ОТМЕНИТЬ ВСЕ
        </button>
        <button id="saveBtn"
          class="bg-black text-white px-5 py-2 rounded-xl hover:bg-gray-900 transition text-sm sm:text-base">
          СОХРАНИТЬ
        </button>
        <button id="guestLogoutBtn"
          class="bg-gray-600 text-white px-5 py-2 rounded-xl hover:bg-gray-700 transition text-sm sm:text-base hidden">
          ВЫЙТИ
        </button>
      </div>
    </div>
    
    <div class="flex flex-col md:flex-row gap-6">
      
      <div id="filterPanel" class="w-full md:w-2/5 md:max-h-[80vh] md:overflow-y-auto md:p-2">
        <div class="mb-2">
          <input type="text" id="searchInput" placeholder="Поиск канала..."
            class="w-full px-4 py-2 border border-gray-300 rounded-xl focus:outline-none focus:ring-2 focus:ring-black" />
        </div>

        <div id="massEditControls" class="bg-gray-200 p-3 rounded-xl mb-4 hidden">
             <h3 class="text-sm font-bold mb-2 text-gray-800">Выбрано: <span id="selectedChannelCount">0</span></h3>
             <button id="deleteSelectedBtn"
                class="bg-red-600 text-white px-3 py-1 rounded-lg hover:bg-red-700 transition text-sm mr-2">
                УДАЛИТЬ ВЫБРАННЫЕ
             </button>
             <button id="openRenameCategoryModalMassBtn"
                class="bg-black text-white px-3 py-1 rounded-lg hover:bg-gray-800 transition text-sm">
                ИЗМЕНИТЬ КАТЕГОРИЮ
             </button>
        </div>
        
        <div class="mb-4">
          <h3 class="text-md font-semibold mb-2 text-gray-800">Сортировка</h3>
          <select id="sortSelect"
              class="w-full px-4 py-2 border border-gray-300 rounded-xl focus:outline-none focus:ring-2 focus:ring-black bg-white">
              <option value="default">По умолчанию (Порядок загрузки)</option>
              <option value="name">По Названию (А-Я)</option>
              <option value="category">По Категории (А-Я)</option>
          </select>
        </div>

        <div class="mb-4">
          <h3 class="text-md font-semibold mb-2 text-gray-800">
              Выбрать категорию для просмотра
              <button id="openRenameCategoryModalBtn" 
                 class="bg-gray-300 text-gray-800 px-2 py-1 rounded-lg hover:bg-gray-400 transition text-xs ml-2">
                 Переименовать
              </button>
          </h3>
          <select id="categorySelect"
              class="w-full px-4 py-2 border border-gray-300 rounded-xl focus:outline-none focus:ring-2 focus:ring-black bg-white">
              <option value="">Все категории</option>
          </select>
        </div>
        <div class="mb-4">
          <h3 class="text-md font-semibold mb-2 text-gray-800">Исключить категории (отметьте, чтобы удалить)</h3>
          <div id="categoryFilter" class="flex flex-wrap gap-2 p-2 bg-gray-50">
            </div>
        </div>
        
      </div>
      
      <div id="listPanel" class="w-full md:w-3/5 md:max-h-[80vh] md:overflow-y-auto md:p-2">
        <div id="selectAllContainer" class="flex items-center p-2 mb-2 bg-gray-100 rounded-xl hidden">
            <input type="checkbox" id="selectAllCheckbox" class="form-checkbox h-5 w-5 text-black rounded border-gray-400 focus:ring-0 mr-3" />
            <label for="selectAllCheckbox" class="text-sm font-semibold text-gray-800">Выбрать все на этой странице</label>
        </div>
        <div id="channelList" class="space-y-2"></div>
      </div>
    </div>
    
  </div>

  <div id="renameChannelModal"
    class="fixed inset-0 flex items-center justify-center bg-black bg-opacity-50 backdrop-blur-sm hidden z-20">
    <div class="bg-white rounded-3xl p-6 w-[90%] max-w-md shadow-xl animate-fade-in text-center text-black">
      <h2 class="text-xl font-semibold mb-6 text-gray-800">Переименовать канал</h2>
      <input type="text" id="renamedChannelName" placeholder="Новое название канала"
        class="w-full px-4 py-3 border border-gray-300 rounded-xl focus:outline-none focus:ring-2 focus:ring-black bg-gray-50 mb-6">
      <button id="submitRenameChannelBtn"
        class="w-full bg-red-600 text-white font-semibold py-3 rounded-xl transition hover:bg-red-700 mb-2">
        ПЕРЕИМЕНОВАТЬ
      </button>
      <button id="closeRenameChannelModal"
        class="w-full bg-gray-200 hover:bg-gray-300 text-gray-900 font-medium py-2 rounded-xl transition">
        ОТМЕНА
      </button>
    </div>
  </div>
  <div id="uploadModal"
    class="fixed inset-0 flex items-center justify-center bg-black bg-opacity-50 backdrop-blur-sm hidden z-20">
    <div class="bg-white rounded-3xl p-6 w-[90%] max-w-md shadow-xl animate-fade-in text-center text-black">
      <h2 class="text-xl font-semibold mb-6 text-gray-800">Загрузка нового плейлиста</h2>

      <div id="dropAreaModal" class="p-4 rounded-2xl border-2 border-transparent transition">
          <button id="uploadModalBtn"
            class="bg-black text-white text-lg font-semibold px-6 py-3 rounded-2xl shadow-lg hover:bg-gray-900 transition w-full mx-auto mb-4">
            ЗАГРУЗИТЬ ФАЙЛ
          </button>
          
          <button id="uploadSingleModalBtn"
            class="bg-black text-white text-lg font-semibold px-6 py-3 rounded-2xl shadow-lg hover:bg-gray-900 transition w-full mx-auto mb-4 hidden">
            ЗАГРУЗИТЬ ФАЙЛ
          </button>
          
          <button id="mergeUploadModalBtn"
            class="bg-blue-600 text-white text-lg font-semibold px-6 py-3 rounded-2xl shadow-lg hover:bg-blue-700 transition w-full mx-auto mb-4 hidden">
            ОБЪЕДИНИТЬ ПЛЕЙЛИСТЫ
          </button>
          <div class="my-4 text-gray-600 hidden">или перетащите сюда</div>
          
          <div class="flex flex-col gap-3 w-full mx-auto mb-4">
            <input type="text" id="urlModalInput" placeholder="Введите ссылку на m3u файл"
              class="w-full px-4 py-3 border border-gray-300 rounded-2xl focus:outline-none focus:ring-2 focus:ring-black bg-gray-50 text-lg shadow-inner">
            
            <button id="loadUrlModalBtn"
              class="w-full bg-black text-white text-lg font-semibold px-6 py-3 rounded-2xl shadow-lg hover:bg-gray-900 transition">
              ВПЕРЕД
            </button>
          </div>
      </div>
      <div id="loadingModal" class="hidden text-blue-600 mt-4">
        <div class="animate-spin rounded-full h-6 w-6 border-b-2 border-blue-600 mx-auto mb-2"></div>
        Загрузка файла...
      </div>

      <button id="closeUploadModal"
        class="w-full bg-gray-200 hover:bg-gray-300 text-gray-900 font-medium py-2 rounded-xl transition mt-4">
        ОТМЕНА
      </button>
    </div>
  </div>

  <div id="addChannelModal"
    class="fixed inset-0 flex items-center justify-center bg-black bg-opacity-50 backdrop-blur-sm hidden z-20">
    <div class="bg-white rounded-3xl p-6 w-[90%] max-w-md shadow-xl animate-fade-in text-center text-black">
      <h2 class="text-xl font-semibold mb-6 text-gray-800">Добавить новый канал</h2>
      <input type="text" id="newChannelName" placeholder="Название канала (Обязательно)"
        class="w-full px-4 py-3 border border-gray-300 rounded-xl focus:outline-none focus:ring-2 focus:ring-black bg-gray-50 mb-4">
      <input type="text" id="newChannelCategory" placeholder="Категория (Group-Title)"
        class="w-full px-4 py-3 border border-gray-300 rounded-xl focus:outline-none focus:ring-2 focus:ring-black bg-gray-50 mb-4">
      <input type="text" id="newChannelLogoUrl" placeholder="URL-ссылка на логотип (tvg-logo)"
        class="w-full px-4 py-3 border border-gray-300 rounded-xl focus:outline-none focus:ring-2 focus:ring-black bg-gray-50 mb-4">
      <input type="text" id="newChannelUrl" placeholder="URL-ссылка на поток (Обязательно)"
        class="w-full px-4 py-3 border border-gray-300 rounded-xl focus:outline-none focus:ring-2 focus:ring-black bg-gray-50 mb-6">
      <button id="submitNewChannelBtn"
        class="w-full bg-green-600 text-white font-semibold py-3 rounded-xl transition hover:bg-green-700 mb-2">
        ДОБАВИТЬ В СПИСОК
      </button>
      <button id="closeAddChannelModal"
        class="w-full bg-gray-200 hover:bg-gray-300 text-gray-900 font-medium py-2 rounded-xl transition">
        ОТМЕНА
      </button>
    </div>
  </div>
  <div id="renameCategoryModal"
    class="fixed inset-0 flex items-center justify-center bg-black bg-opacity-50 backdrop-blur-sm hidden z-20">
    <div class="bg-white rounded-3xl p-6 w-[90%] max-w-md shadow-xl animate-fade-in text-center text-black">
      <h2 class="text-xl font-semibold mb-6 text-gray-800">Переименовать/Изменить Категорию</h2>
      <select id="oldCategorySelect"
              class="w-full px-4 py-3 border border-gray-300 rounded-xl focus:outline-none focus:ring-2 focus:ring-black bg-white mb-4">
              </select>
      <input type="text" id="newCategoryName" placeholder="Новое название категории"
        class="w-full px-4 py-3 border border-gray-300 rounded-xl focus:outline-none focus:ring-2 focus:ring-black bg-gray-50 mb-6">
      <button id="submitRenameCategoryBtn"
        class="w-full bg-red-600 text-white font-semibold py-3 rounded-xl transition hover:bg-red-700 mb-2">
        ПЕРЕИМЕНОВАТЬ
      </button>
      <button id="closeRenameCategoryModal"
        class="w-full bg-gray-200 hover:bg-gray-300 text-gray-900 font-medium py-2 rounded-xl transition">
        ОТМЕНА
      </button>
    </div>
  </div>
  <div id="registrationModal"
    class="fixed inset-0 flex items-center justify-center bg-black bg-opacity-50 backdrop-blur-sm hidden z-20">
    <div class="bg-white rounded-3xl shadow-xl animate-fade-in text-center text-black square-modal-content">
      
      <button id="closeRegisterModal"
        class="absolute top-4 right-4 text-gray-400 hover:text-gray-600 transition p-1 rounded-full hover:bg-gray-100">
        <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
        </svg>
      </button>

      <h2 class="text-2xl font-extrabold text-center mb-4 text-gray-800">
        Добро пожаловать!
      </h2>
      <p class="text-center text-gray-600 mb-8 text-sm">
        Создайте свой аккаунт, чтобы сохранять плейлисты.
      </p>

      <button id="registerGoogleBtn"
        class="w-full flex items-center justify-center bg-white border border-gray-300 text-gray-700 text-base font-medium px-4 py-3 rounded-xl shadow-sm hover:bg-gray-100 transition mb-3">
        <svg class="w-5 h-5 mr-3" viewBox="0 0 24 24" fill="currentColor">
          <path d="M12.0003 4.75C14.7173 4.75 16.9833 5.772 18.6673 7.359L20.5903 5.487C18.3143 3.498 15.3623 2.25 12.0003 2.25C8.01332 2.25 4.54932 4.53 2.87132 7.824L5.87532 10.125C6.73632 7.787 9.12632 6.25 12.0003 6.25C13.8823 6.25 15.6173 6.942 16.9803 8.167L19.4583 6.135C18.0493 4.904 16.1433 4.25 14.2503 4.25H12.0003V4.75Z" fill="#EA4335"/>
          <path d="M12.0003 17.75C13.2133 17.75 14.3723 17.419 15.3853 16.829L18.3903 19.13C16.6383 20.375 14.3763 21 12.0003 21C7.81732 21 4.28832 18.577 2.50232 15.111L5.53732 12.83C6.34732 15.309 9.07332 17 12.0003 17V17.75Z" fill="#34A853"/>
          <path d="M21.2503 12C21.2503 11.234 21.1813 10.493 21.0543 9.774H12.0003V14.25H17.2273C17.0673 15.186 16.5183 15.996 15.7503 16.591L18.7853 18.868C20.4433 17.375 21.2503 15.342 21.2503 13.007V12Z" fill="#4285F4"/>
          <path d="M5.87532 10.125L2.87132 7.824C2.26132 9.068 2.00032 10.493 2.00032 12C2.00032 13.507 2.26132 14.932 2.87132 16.176L5.87532 13.875V10.125Z" fill="#FBBC05"/>
        </svg>
        Войти через Google
      </button>
      
      </div>
  </div>
  <div id="saveModal"
    class="fixed inset-0 flex items-center justify-center bg-black bg-opacity-50 backdrop-blur-sm hidden z-20">
    <div class="bg-white rounded-3xl p-6 w-[90%] max-w-md shadow-xl animate-fade-in text-center text-black">
      <h2 id="finalFileName" class="text-2xl font-bold mb-6">ФАЙЛ 0 КАНАЛОВ</h2>

      <div id="dynamicLinkContainer" class="mb-6 p-4 bg-gray-100 rounded-xl text-left">
          <h3 class="text-sm font-bold text-gray-800 mb-2">Ваша Короткая Динамическая Ссылка</h3>
          <div id="shortLinkLoader" class="text-center text-blue-600 mb-2 hidden">
              <div class="animate-spin rounded-full h-4 w-4 border-b-2 border-blue-600 mx-auto mb-1"></div>
              Сокращаю...
          </div>
          <input type="text" id="dynamicPlaylistLink" readonly
            class="w-full text-sm font-mono p-2 border border-gray-300 rounded-lg bg-white truncate">
          <button id="copyLinkBtn"
            class="w-full mt-2 bg-blue-600 text-white font-medium py-1 rounded-lg transition hover:bg-blue-700 text-sm">
            КОПИРОВАТЬ ССЫЛКУ
          </button>
      </div>

      <div id="formatSelectContainer" class="mb-4">
        <label for="formatSelect" class="text-sm font-bold text-gray-800 block mb-2 text-left">Формат скачивания:</label>
        <select id="formatSelect"
            class="w-full px-4 py-2 border border-gray-300 rounded-xl focus:outline-none focus:ring-2 focus:ring-black bg-white">
            <option value="m3u">M3U</option>
            <option value="m3u8">M3U8</option>
            <option value="txt">TXT</option>
        </select>
      </div>
      
      <p id="guestFormatMessage" class="mb-4 text-sm font-bold text-gray-800 hidden text-left">
         Формат скачивания для неавторизованных: **M3U**
      </p>

      <button id="downloadBtn"
        class="w-full bg-black text-white font-medium py-2 rounded-xl transition hover:bg-gray-800 mb-2">
        СКАЧАТЬ ЛОКАЛЬНО
      </button>
      <button id="closeSaveModal"
        class="w-full bg-gray-200 hover:bg-gray-300 text-gray-900 font-medium py-2 rounded-xl transition">
        ЗАКРЫТЬ
      </button>
    </div>
  </div>
  
  <div id="toastNotification" class="fixed bottom-5 right-5 bg-green-600 text-white px-4 py-3 rounded-xl shadow-lg hidden animate-fade-in z-50">
    Плейлист загружен. Каналов: <span id="toastChannelCount" class="font-bold">0</span>
  </div>

  <div id="globalLoader" class="fixed inset-0 flex flex-col items-center justify-center bg-black bg-opacity-50 backdrop-blur-sm hidden z-50">
    <div class="animate-spin rounded-full h-16 w-16 border-b-4 border-white mb-4"></div>
    <p class="text-white text-xl font-semibold">Обработка плейлиста...</p>
  </div>


  <script type="module">
    // =======================================================
    // FIREBASE INITIALIZATION AND AUTH
    // =======================================================
    import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
    import { 
        getAuth, 
        signInAnonymously, 
        signInWithCustomToken, 
        createUserWithEmailAndPassword,
        signInWithEmailAndPassword, // Импортируем функцию для входа
        GoogleAuthProvider,
        signInWithPopup,
        signOut,
        onAuthStateChanged 
    } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";

    // Использование конфигурации, предоставленной пользователем, с учетом глобальных переменных Canvas
    const providedFirebaseConfig = {
      apiKey: "AIzaSyCko3aktIDmXWbsDekdr-dKUscX2fkRpjo",
      authDomain: "read24-7.firebaseapp.com",
      projectId: "read24-7",
      storageBucket: "read24-7.firebasestorage.app",
      messagingSenderId: "966949567813",
      appId: "1:966949567813:web:b12ff4001282d20c29922c",
      measurementId: "G-NVEC5F7S8F"
    };

    const firebaseConfig = JSON.parse(typeof __firebase_config !== 'undefined' ? __firebase_config : JSON.stringify(providedFirebaseConfig));
    const app = initializeApp(firebaseConfig);
    const auth = getAuth(app);
    
    let userId = 'guest';
    let isAnonymousUser = true; // Флаг для отслеживания анонимного статуса

    // Авторизация при запуске
    async function initializeAuth() {
        try {
            if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) {
                await signInWithCustomToken(auth, __initial_auth_token);
                // console.log("Signed in with custom token.");
            } else {
                await signInAnonymously(auth);
                // console.log("Signed in anonymously.");
            }
        } catch (error) {
            console.error("Auth initialization failed:", error.message);
        }
    }

    // ВОССТАНОВЛЕНА ЛОГИКА ДЛЯ АУТЕНТИФИКАЦИИ С ПЕРЕХОДОМ В РЕДАКТОР
    onAuthStateChanged(auth, (user) => {
        const isAuthenticated = user && !user.isAnonymous;
        isAnonymousUser = !isAuthenticated; // Обновляем флаг
        
        // 1. Скрываем/показываем контейнеры
        if (!isAuthenticated) {
            // Гость:
            unauthenticatedMessage.classList.add('hidden'); 
            authButtonContainer.classList.add('hidden');
            
            // Управление кнопками в шапке
            openRegisterModalBtn.classList.remove('hidden'); // Показываем "ВОЙТИ / РЕГИСТРАЦИЯ"
            logoutBtn.classList.add('hidden');
            userId = 'guest';
            
            // Скрываем кнопку ОБЪЕДИНЕНИЯ и одиночную для авторизованных
            if (mergeUploadModalBtn) mergeUploadModalBtn.classList.add('hidden');
            if (uploadSingleModalBtn) uploadSingleModalBtn.classList.add('hidden');
            if (uploadModalBtn) uploadModalBtn.classList.remove('hidden'); // Показываем одиночную для гостей
            // Устанавливаем fileInput для одного файла
            if (fileInput) fileInput.removeAttribute('multiple');
            
            // ЕСЛИ НЕ АВТОРИЗОВАН, ПОКАЗЫВАЕМ ГЛАВНЫЕ БЛОКИ
            if (mainScreen) mainScreen.classList.remove('hidden'); 
            if (editorScreen) editorScreen.classList.add('hidden');
            if (heroBlock) heroBlock.classList.remove('hidden');
            if (whyUsBlock) whyUsBlock.classList.remove('hidden');
            if (howItWorksBlock) howItWorksBlock.classList.remove('hidden');
            if (comparisonBlock) comparisonBlock.classList.remove('hidden');
            if (faqBlock) faqBlock.classList.remove('hidden');

            // УПРАВЛЕНИЕ КНОПКАМИ В РЕДАКТОРЕ ДЛЯ ГОСТЯ
            if (editorScreen.classList.contains('hidden') === false) {
                 openUploadModalBtn.classList.remove('hidden'); // Загрузка доступна
                 saveBtn.classList.remove('hidden'); // СОХРАНИТЬ ВИДНА
                 guestLogoutBtn.classList.remove('hidden'); // ВЫХОД ВИДЕН
                 revertBtn.classList.add('hidden'); // Скрываем отмену для гостя
                 
                 // Применяем стили 2x2 для кнопок редактора гостя на мобильных
                 if (window.innerWidth <= 640) {
                     document.getElementById('editorButtonsContainer').classList.add('guest-buttons-container-mobile');
                     // Скрываем flex-row, чтобы работал grid
                     document.getElementById('editorButtonsContainer').classList.remove('flex-row', 'space-x-2');
                 } else {
                     document.getElementById('editorButtonsContainer').classList.remove('guest-buttons-container-mobile');
                     document.getElementById('editorButtonsContainer').classList.add('flex-row', 'space-x-2');
                 }
            }
            
        } else {
            // Пользователь вошел:
            // Скрываем главный экран и все его компоненты
            mainScreen.classList.add('hidden'); 
            // Показываем редактор
            editorScreen.classList.remove('hidden');
            
            // Управление кнопками в шапке
            openRegisterModalBtn.classList.add('hidden'); // Скрываем "ВОЙТИ / РЕГИСТРАЦИЯ"
            logoutBtn.classList.remove('hidden'); // Показываем "ВЫЙТИ"
            userId = user.uid; 
            
            // Показываем кнопку ОБЪЕДИНЕНИЯ и одиночную для авторизованных
            if (mergeUploadModalBtn) mergeUploadModalBtn.classList.remove('hidden');
            if (uploadSingleModalBtn) uploadSingleModalBtn.classList.remove('hidden');
            if (uploadModalBtn) uploadModalBtn.classList.add('hidden'); // Скрываем гостевую кнопку
            // Устанавливаем fileInput для множественного выбора
            if (fileInput) fileInput.setAttribute('multiple', true);

            // ПОЛНЫЙ ФУНКЦИОНАЛ ДЛЯ АВТОРИЗОВАННОГО ПОЛЬЗОВАТЕЛЯ
            openUploadModalBtn.classList.remove('hidden');
            saveBtn.classList.remove('hidden');
            guestLogoutBtn.classList.add('hidden'); // ВЫХОД СКРЫТ
            revertBtn.classList.remove('hidden'); // Показываем отмену для авторизованного
            
            // Сброс стилей 2x2, если вдруг они применились
            document.getElementById('editorButtonsContainer').classList.remove('guest-buttons-container-mobile');
            document.getElementById('editorButtonsContainer').classList.add('flex-row', 'space-x-2');
        }
    });

    initializeAuth();

    // =======================================================
    // REGISTRATION AND LOGOUT FUNCTIONS
    // =======================================================
    
    // УДАЛЕНА handleEmailSignIn
    async function handleEmailSignIn(email, password) {
        // Логика удалена, оставил заглушку для совместимости с кодом
        console.warn("Email sign-in is disabled. Use Google sign-in.");
        showToast("Вход по Email/Паролю отключен. Используйте Google.");
        return false;
    }

    // УДАЛЕНА handleEmailRegistration
    async function handleEmailRegistration(e) {
        e.preventDefault();
        // Логика удалена, оставил заглушку для совместимости с кодом
        console.warn("Email registration is disabled. Use Google sign-in.");
        showToast("Регистрация по Email/Паролю отключена. Используйте Google.");
    }


    async function handleGoogleRegistration() {
        const provider = new GoogleAuthProvider();
        try {
            await signInWithPopup(auth, provider);
            showToast("Вход через Google успешен!");
            registrationModal.classList.add('hidden');
        } catch (error) {
            let errorMessage = "Ошибка входа через Google.";
            // Обработка закрытия окна пользователем (popup-closed-by-user)
            if (error.code === 'auth/popup-closed-by-user') {
                errorMessage = "Окно входа было закрыто.";
            } else {
                errorMessage = `Ошибка: ${error.message}`;
            }
            showToast(errorMessage);
            console.error("Google sign-in error:", error.code, error.message);
        }
    }
    
    async function handleLogout() {
        try {
            await signOut(auth);
            
            // Дополнительная логика сброса UI после onAuthStateChanged
            mainScreen.classList.remove('hidden');
            editorScreen.classList.add('hidden');
            // Прокрутка наверх (к главному экрану)
            window.scrollTo({ top: 0, behavior: 'smooth' });
            
            showToast("Вы успешно вышли из аккаунта.");
        } catch (error) {
            console.error("Logout error:", error.message);
            showToast("Ошибка при выходе.");
        }
    }

    // =======================================================
    // EXISTING SCRIPT LOGIC BELOW
    // =======================================================
    const uploadBtn = document.getElementById('uploadBtn');
    const fileInput = document.getElementById('fileInput');
    const urlInput = document.getElementById('urlInput');
    const loadUrlBtn = document.getElementById('loadUrlBtn');
    const loading = document.getElementById('loading');
    const saveModal = document.getElementById('saveModal');
    // const channelCounter = document.getElementById('channelCounter'); // УДАЛЕН
    const editorChannelCounter = document.getElementById('editorChannelCounter'); // НОВЫЙ СЧЕТЧИК
    const finalFileName = document.getElementById('finalFileName');
    const downloadBtn = document.getElementById('downloadBtn');
    const closeSaveModal = document.getElementById('closeSaveModal');
    const mainScreen = document.getElementById('mainScreen');
    const editorScreen = document.getElementById('editorScreen');
    const channelList = document.getElementById('channelList');
    const saveBtn = document.getElementById('saveBtn');
    const searchInput = document.getElementById('searchInput');
    const categoryFilter = document.getElementById('categoryFilter'); 
    const removeDuplicatesBtn = document.getElementById('removeDuplicatesBtn'); 
    const dropArea = document.getElementById('dropArea');
    const categorySelect = document.getElementById('categorySelect'); 
    const formatSelect = document.getElementById('formatSelect'); // НОВЫЙ SELECT
    
    const uploadModal = document.getElementById('uploadModal');
    const openUploadModalBtn = document.getElementById('openUploadModalBtn');
    const closeUploadModal = document.getElementById('closeUploadModal');
    const uploadModalBtn = document.getElementById('uploadModalBtn');
    const urlModalInput = document.getElementById('urlModalInput');
    const loadUrlModalBtn = document.getElementById('loadUrlModalBtn');
    const loadingModal = document.getElementById('loadingModal');
    const dropAreaModal = document.getElementById('dropAreaModal'); 
    
    const toastNotification = document.getElementById('toastNotification');
    const toastChannelCount = document.getElementById('toastChannelCount');

    const globalLoader = document.getElementById('globalLoader');

    // ПЕРЕМЕННЫЕ ДЛЯ РЕГИСТРАЦИИ/АУТЕНТИФИКАЦИИ
    const registrationModal = document.getElementById('registrationModal');
    // Используем новую кнопку в шапке
    const openRegisterModalBtnHeader = document.getElementById('openRegisterModalBtnHeader'); 
    const openRegisterModalBtn = openRegisterModalBtnHeader; // Переназначаем, чтобы не менять все обработчики
    // const closeRegisterModal = document.getElementById('closeRegisterModal'); // УДАЛЕНО
    const registerEmailBtn = document.getElementById('registerEmailBtn');
    const registerGoogleBtn = document.getElementById('registerGoogleBtn');
    const registrationFormElement = document.getElementById('registrationFormElement');
    const loginLink = document.getElementById('loginLink'); // Получаем ссылку "Войти"
    
    const unauthenticatedMessage = document.getElementById('unauthenticatedMessage');
    const authButtonContainer = document.getElementById('authButtonContainer');
    
    // Элементы для динамической ссылки
    const dynamicPlaylistLink = document.getElementById('dynamicPlaylistLink');
    const copyLinkBtn = document.getElementById('copyLinkBtn');
    const shortLinkLoader = document.getElementById('shortLinkLoader');
    
    // Элементы для выбора формата
    const formatSelectContainer = document.getElementById('formatSelectContainer');
    const guestFormatMessage = document.getElementById('guestFormatMessage');
    
    // НОВЫЕ ПЕРЕМЕННЫЕ
    const editorButtonsContainer = document.getElementById('editorButtonsContainer');
    const heroBlock = document.getElementById('heroBlock'); 
    const whyUsBlock = document.getElementById('whyUsBlock'); 
    const howItWorksBlock = document.getElementById('howItWorksBlock'); 
    const comparisonBlock = document.getElementById('comparisonBlock');
    const faqBlock = document.getElementById('faqBlock');
    const knowledgeBaseBlock = document.getElementById('knowledgeBaseBlock'); // Новый блок
    const goToWhyUsBtn = document.getElementById('goToWhyUsBtn'); 
    const startEditingBtn = document.getElementById('startEditingBtn'); 
    const registerNowBtn = document.getElementById('registerNowBtn'); 
    const registerNowCardBtn = document.getElementById('registerNowCardBtn');
    const startNoRegBtn = document.getElementById('startNoRegBtn');
    const dynamicTitlePart = document.getElementById('dynamicTitlePart');
    const menuButton = document.getElementById('menuButton'); // Кнопка гамбургера
    const siteMenu = document.getElementById('siteMenu'); // Мобильное меню
    const knowledgeBaseLink = document.getElementById('knowledgeBaseLink'); // Ссылка на Базу знаний
    const freePlaylistsLink = document.getElementById('freePlaylistsLink'); // Ссылка на Полезные программы
    // *** НОВАЯ КНОПКА ВЫХОДА В РЕДАКТОРЕ ***
    const guestLogoutBtn = document.getElementById('guestLogoutBtn'); 

    // [ПЕРЕИМЕНОВАТЬ: НОВОЕ] Переменные для модального окна переименования
    const renameChannelModal = document.getElementById('renameChannelModal');
    const closeRenameChannelModal = document.getElementById('closeRenameChannelModal');
    const submitRenameChannelBtn = document.getElementById('submitRenameChannelBtn');
    const renamedChannelName = document.getElementById('renamedChannelName');
    let currentChannelToRename = null; // Хранит объект канала, который переименовывается
    // [ПЕРЕИМЕНОВАТЬ: КОНЕЦ НОВОГО]

    // НОВАЯ КНОПКА ОБЪЕДИНЕНИЯ В МОДАЛКЕ
    const mergeUploadModalBtn = document.getElementById('mergeUploadModalBtn'); 
    // НОВАЯ КНОПКА ОДИНОЧНОЙ ЗАГРУЗКИ ДЛЯ АВТОРИЗОВАННЫХ В МОДАЛКЕ
    const uploadSingleModalBtn = document.getElementById('uploadSingleModalBtn'); 
    // КОНЕЦ НОВЫХ ПЕРЕМЕННЫХ
    
    // НОВАЯ ПЕРЕМЕННАЯ ДЛЯ КРЕСТИКА
    const closeRegisterModalIcon = document.getElementById('closeRegisterModal');

    // ПЕРЕМЕННЫЕ ДЛЯ ДОБАВЛЕНИЯ КАНАЛА
    const addChannelBtn = document.getElementById('addChannelBtn');
    const addChannelModal = document.getElementById('addChannelModal');
    const closeAddChannelModal = document.getElementById('closeAddChannelModal');
    const submitNewChannelBtn = document.getElementById('submitNewChannelBtn');
    const newChannelName = document.getElementById('newChannelName');
    const newChannelCategory = document.getElementById('newChannelCategory');
    // [ЛОГО: ИЗМЕНЕНИЕ] Новая переменная для лого
    const newChannelLogoUrl = document.getElementById('newChannelLogoUrl'); 
    // [ЛОГО: КОНЕЦ ИЗМЕНЕНИЯ]
    const newChannelUrl = document.getElementById('newChannelUrl');
    
    // ПЕРЕМЕННЫЕ ДЛЯ ПЕРЕИМЕНОВАНИЯ КАТЕГОРИИ
    const renameCategoryModal = document.getElementById('renameCategoryModal');
    const closeRenameCategoryModal = document.getElementById('closeRenameCategoryModal');
    const openRenameCategoryModalBtn = document.getElementById('openRenameCategoryModalBtn');
    const oldCategorySelect = document.getElementById('oldCategorySelect');
    const newCategoryName = document.getElementById('newCategoryName');
    const submitRenameCategoryBtn = document.getElementById('submitRenameCategoryBtn');
    // ПЕРЕМЕННЫЕ ДЛЯ МАССОВОГО РЕДАКТИРОВАНИЯ
    const massEditControls = document.getElementById('massEditControls');
    const selectedChannelCount = document.getElementById('selectedChannelCount');
    const deleteSelectedBtn = document.getElementById('deleteSelectedBtn');
    const openRenameCategoryModalMassBtn = document.getElementById('openRenameCategoryModalMassBtn');
    const selectAllCheckbox = document.getElementById('selectAllCheckbox');
    const selectAllContainer = document.getElementById('selectAllContainer');
    
    // ПЕРЕМЕННЫЕ ДЛЯ СОРТИРОВКИ
    const sortSelect = document.getElementById('sortSelect');
    
    // ПЕРЕМЕННЫЕ ДЛЯ ОТМЕНЫ
    const revertBtn = document.getElementById('revertBtn'); // НОВАЯ КНОПКА ОТМЕНЫ

    let originalLines = [];
    let channels = [];
    let allCategories = new Set();
    let excludedCategories = new Set(); 
    let editedContent = ''; // Переменная для хранения контента плейлиста для скачивания
    let categoryChannelCounts = {}; 
    
    // ДАННЫЕ ДЛЯ ОТМЕНЫ
    let originalChannels = []; // Хранит исходный массив каналов для отмены
    let originalCategories = new Set(); // Хранит исходный набор категорий
    
    const FAVORITE_CATEGORY = 'ИЗБРАННОЕ'; 
    const DISPLAY_FAVORITE_CATEGORY = '✨ИЗБРАННОЕ✨'; 
    
    // *** НОВОЕ: URL ДЛЯ EPG (Обновлено на is.gd/epg2xml) ***
    const EPG_URL = 'https://is.gd/epg2xml'; 
    // *******************************************************

    // [ЛОГО: ИЗМЕНЕНИЕ] Обновленный базовый URL для логотипов
    const DEFAULT_LOGO_BASE_URL = 'https://raw.githubusercontent.com/25aibiz25-maker/edit/refs/heads/main/';

    // =======================================================
    // ЛОГИКА ДИНАМИЧЕСКОГО ТЕКСТА
    // =======================================================
    const dynamicPhrases = [
        'вашего удобства', 
        'любых устройств', 
        'быстрого доступа', 
        'идеального порядка', 
        'полного контроля'
    ];
    let currentPhraseIndex = 0;

    function updateDynamicTitle() {
        if (dynamicTitlePart) {
            // 1. Установка нового текста
            dynamicTitlePart.textContent = dynamicPhrases[currentPhraseIndex];
            
            // 2. Сброс анимации (важно для повторного запуска)
            dynamicTitlePart.classList.remove('dynamic-text-animated');
            // Переинициализация анимации через небольшой таймаут
            void dynamicTitlePart.offsetWidth; // Force reflow
            dynamicTitlePart.classList.add('dynamic-text-animated'); 
            
            // 3. Обновление индекса
            currentPhraseIndex = (currentPhraseIndex + 1) % dynamicPhrases.length;
        }
    }

    // Запуск динамического текста только после загрузки всех элементов
    if (dynamicTitlePart) {
        updateDynamicTitle(); // Установка первого значения
        setInterval(updateDynamicTitle, 2000); 
    }
    // =======================================================

    // =======================================================
    // ЛОГИКА DRAG AND DROP (УДАЛЕНО)
    // =======================================================
    const dragDropAreas = [dropArea, dropAreaModal];

    dragDropAreas.forEach(area => {
        if (area) {
            ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
                area.removeEventListener(eventName, preventDefaults, false);
            });
            document.body.removeEventListener('dragover', preventDefaults, false); 
            document.body.removeEventListener('drop', preventDefaults, false);
            ['dragenter', 'dragover'].forEach(eventName => {
                area.removeEventListener(eventName, highlight, false);
            });
            ['dragleave', 'drop'].forEach(eventName => {
                area.removeEventListener(eventName, unhighlight, false);
            });
            area.removeEventListener('drop', handleDrop, false);
        }
    });

    function preventDefaults(e) {
      e.preventDefault();
      e.stopPropagation();
    }

    function highlight(e) {
      // e.currentTarget.classList.add('drag-over'); 
    }

    function unhighlight(e) {
      // e.currentTarget.classList.remove('drag-over'); 
    }

    function handleDrop(e) {
      const dt = e.dataTransfer;
      const files = dt.files;
      if (files.length > 0) {
        handleFiles(files);
      }
    }

    function handleFiles(files) {
        // Логика была изменена: теперь fileInput.files = files; и запуск change.
        if (!files || files.length === 0) return;
        
        fileInput.files = files;
        fileInput.dispatchEvent(new Event('change'));
    }
    
    // =======================================================
    // ФУНКЦИИ УВЕДОМЛЕНИЯ
    // =======================================================
    function showToast(message, count = null) {
        toastChannelCount.classList.add('hidden');
        toastNotification.classList.remove('bg-green-600', 'bg-red-600'); 
        
        if (count !== null) {
            toastChannelCount.textContent = count;
            toastNotification.innerHTML = `Плейлист загружен. Каналов: <span class="font-bold">${count}</span>`;
            toastNotification.classList.add('bg-green-600'); 
        } else {
            toastNotification.textContent = message;
            if (message.includes('Ошибка') || message.includes('Не удалось') || message.includes('Пожалуйста') || message.includes('Неверный')) {
                 toastNotification.classList.add('bg-red-600'); 
            } else {
                 toastNotification.classList.add('bg-green-600');
            }
        }
        
        toastNotification.classList.remove('hidden');
        toastNotification.classList.add('animate-fade-in');

        setTimeout(() => {
            toastNotification.classList.add('hidden');
            toastNotification.classList.remove('animate-fade-in');
        }, 3000);
    }
    
    // =======================================================
    // ОБРАБОТЧИКИ СОБЫТИЙ
    // =======================================================

    // *** ИЗМЕНЕННЫЙ ОБРАБОТЧИК fileInput ***
    fileInput.addEventListener('change', () => {
      const files = fileInput.files;
      if (files.length === 0) {
          return;
      }
    
      globalLoader.classList.remove('hidden');
      uploadModal.classList.add('hidden');
      
      const isMerge = files.length > 1 || channels.length > 0; // Флаг для слияния

      // Создаем массив промисов для обработки каждого файла
      const filePromises = Array.from(files).map(file => {
          return new Promise((resolve, reject) => {
              const reader = new FileReader();
              reader.onload = function (e) {
                  resolve(e.target.result); // Возвращаем контент
              };
              reader.onerror = reject;
              reader.readAsText(file);
          });
      });

      // Последовательная обработка всех файлов
      Promise.all(filePromises)
          .then(contents => {
              let combinedContent = '';
              // Объединяем контент всех файлов в одну строку для парсинга
              contents.forEach(content => {
                  combinedContent += content + '\n'; 
              });
              
              // Вызываем главную функцию обработки с объединенным контентом и флагом слияния
              processPlaylistContent(combinedContent, isMerge); 
          })
          .catch(error => {
              globalLoader.classList.add('hidden');
              showToast('Ошибка при чтении одного или нескольких файлов: ' + error.message);
          });
    });
    // *** КОНЕЦ ИЗМЕНЕННОГО ОБРАБОТЧИКА fileInput ***

    openUploadModalBtn.addEventListener('click', () => {
        // Открываем модальное окно для загрузки из редактора
        uploadModal.classList.remove('hidden');
        // Обновляем видимость кнопок в модалке
        if (isAnonymousUser) {
            uploadModalBtn.classList.remove('hidden');
            uploadSingleModalBtn.classList.add('hidden');
            mergeUploadModalBtn.classList.add('hidden');
            fileInput.removeAttribute('multiple');
        } else {
            uploadModalBtn.classList.add('hidden'); // Скрываем гостевую кнопку
            uploadSingleModalBtn.classList.remove('hidden'); // Показываем одиночную для авторизованных
            mergeUploadModalBtn.classList.remove('hidden'); // Показываем множественную
            // Важно: fileInput.multiple должен быть установлен в обработчиках кнопок
        }
    });

    // Обработчик для кнопки "ЗАГРУЗИТЬ ФАЙЛ" (для гостя - одиночный выбор)
    uploadModalBtn.addEventListener('click', () => {
        fileInput.removeAttribute('multiple'); // На всякий случай, если была установлена
        fileInput.click();
    });
    
    // *** НОВЫЙ ОБРАБОТЧИК ДЛЯ КНОПКИ "ЗАГРУЗИТЬ ФАЙЛ" (для авторизованных) ***
    uploadSingleModalBtn.addEventListener('click', () => {
        fileInput.removeAttribute('multiple'); // Для одиночной загрузки
        fileInput.click();
    });
    // *** КОНЕЦ НОВОГО ОБРАБОТЧИКА ***
    
    // *** НОВЫЙ ОБРАБОТЧИК ДЛЯ КНОПКИ "ОБЪЕДИНИТЬ ПЛЕЙЛИСТЫ" ***
    mergeUploadModalBtn.addEventListener('click', () => {
        fileInput.setAttribute('multiple', true);
        fileInput.click();
    });
    // *** КОНЕЦ НОВОГО ОБРАБОТЧИКА ***
    
    loadUrlModalBtn.addEventListener('click', async () => {
      const url = urlModalInput.value.trim();
      // Загрузка через модальное окно
      await loadPlaylistFromUrl(url, loadingModal, loadUrlModalBtn);
    });

    closeUploadModal.addEventListener('click', () => {
        uploadModal.classList.add('hidden');
    });
    
    // ОБРАБОТЧИК КОПИРОВАНИЯ ДИНАМИЧЕСКОЙ ССЫЛКИ
    copyLinkBtn.addEventListener('click', () => {
        const link = dynamicPlaylistLink.value;
        navigator.clipboard.writeText(link).then(() => {
            showToast("Ссылка скопирована в буфер обмена!");
        }).catch(err => {
            console.error('Could not copy text: ', err);
            showToast("Ошибка копирования. Попробуйте вручную.");
        });
    });


    // ОБРАБОТЧИКИ МОДАЛЬНОГО ОКНА РЕГИСТРАЦИИ
    if (openRegisterModalBtn) {
        openRegisterModalBtn.addEventListener('click', () => {
            registrationModal.classList.remove('hidden');
        });
    }

    if (closeRegisterModalIcon) {
        closeRegisterModalIcon.addEventListener('click', () => {
            registrationModal.classList.add('hidden');
        });
    }
    
    // Добавляем обработчик для ссылки "Войти" (Теперь он просто показывает модальное окно Google)
    if (loginLink) {
        loginLink.addEventListener('click', (e) => {
            e.preventDefault();
            handleGoogleRegistration(); // Перенаправляем на Google
        });
    }

    // Подключение функций регистрации и выхода
    // Заглушки, так как формы по Email нет
    if (registrationFormElement) {
        registrationFormElement.addEventListener('submit', handleEmailRegistration);
    }
    
    if (registerGoogleBtn) {
        registerGoogleBtn.addEventListener('click', handleGoogleRegistration);
    }
    
    // ИЗМЕНЕНИЕ: Теперь handleLogout содержит всю логику сброса UI, чтобы гарантировать возврат на главную страницу.
    document.getElementById('logoutBtn').addEventListener('click', handleLogout); 
    
    // *** НОВЫЙ ОБРАБОТЧИК ДЛЯ КНОПКИ ВЫХОДА В РЕДАКТОРЕ ***
    if (guestLogoutBtn) {
        guestLogoutBtn.addEventListener('click', () => {
            // Принудительный сброс UI в состояние "Гость"
            mainScreen.classList.remove('hidden');
            editorScreen.classList.add('hidden');
            // Очищаем список каналов
            channels = [];
            channelList.innerHTML = '';
            updateCounter();
            renderCategoryFilter();
            renderCategorySelect();
            revertBtn.classList.add('hidden'); // Скрываем кнопку отмены
            showToast("Выход из режима редактирования.");
            // Прокрутка наверх
            window.scrollTo({ top: 0, behavior: 'smooth' });
        });
    }
    // *** КОНЕЦ НОВОГО ОБРАБОТЧИКА ***
    
    // НОВЫЙ ОБРАБОТЧИК: Кнопка Регистрация в таблице
    if (registerNowBtn) {
        registerNowBtn.addEventListener('click', () => {
             registrationModal.classList.remove('hidden');
        });
    }
    // НОВЫЙ ОБРАБОТЧИК: Кнопка Регистрация в карточке
    if (registerNowCardBtn) {
        registerNowCardBtn.addEventListener('click', () => {
             registrationModal.classList.remove('hidden');
        });
    }
    
    // ДОБАВЛЕНА ЛОГИКА АККОРДЕОНА ДЛЯ FAQ
    window.toggleFaq = function(element) {
        const isExpanded = element.getAttribute('aria-expanded') === 'true';
        
        // Скрываем все остальные открытые
        document.querySelectorAll('.faq-item[aria-expanded="true"]').forEach(item => {
            if (item !== element) {
                item.setAttribute('aria-expanded', 'false');
            }
        });

        // Переключаем текущий элемент
        element.setAttribute('aria-expanded', !isExpanded);
    }
    
    // ЛОГИКА ГАМБУРГЕРА (РАСКРЫТИЕ/СКРЫТИЕ)
    if (menuButton && siteMenu) {
        menuButton.addEventListener('click', () => {
            siteMenu.classList.toggle('open');
        });
        
        // Добавляем закрытие меню при клике по ссылке (только для мобильной версии)
        document.querySelectorAll('#siteMenu .menu-link').forEach(link => {
            link.addEventListener('click', () => {
                if (window.innerWidth <= 640) {
                     siteMenu.classList.remove('open');
                }
            });
        });
    
    }
    
    // *** ИЗМЕНЕННЫЙ ОБРАБОТЧИК: Кнопки "Начать редактирование" ***
    function handleStartEditing() {
        // 1. Показываем модальное окно загрузки
        uploadModal.classList.remove('hidden');

        // 2. Скрываем главный экран и показываем редактор
        mainScreen.classList.add('hidden');
        editorScreen.classList.remove('hidden');
        
        // 3. Настраиваем видимость кнопок в редакторе в зависимости от статуса
        if (isAnonymousUser) {
             // Для гостя: СОХРАНИТЬ ВИДНА, ЗАГРУЗКА ВИДНА, ВЫХОД ВИДЕН
             saveBtn.classList.remove('hidden'); 
             openUploadModalBtn.classList.remove('hidden');
             guestLogoutBtn.classList.remove('hidden'); 
             revertBtn.classList.add('hidden'); // Скрываем отмену для гостя
             
             // Обновляем кнопки в модалке для гостя
             uploadModalBtn.classList.remove('hidden'); // Показываем гостевую
             uploadSingleModalBtn.classList.add('hidden');
             mergeUploadModalBtn.classList.add('hidden');
             fileInput.removeAttribute('multiple');
             
             // Применяем стили 2x2 для кнопок редактора гостя на мобильных
             if (window.innerWidth <= 640) {
                 editorButtonsContainer.classList.add('guest-buttons-container-mobile');
                 editorButtonsContainer.classList.remove('flex-row', 'space-x-2');
             } else {
                 editorButtonsContainer.classList.remove('guest-buttons-container-mobile');
                 editorButtonsContainer.classList.add('flex-row', 'space-x-2');
             }
        } else {
             // Для авторизованного: показываем все, ВЫХОД СКРЫТ
             saveBtn.classList.remove('hidden');
             openUploadModalBtn.classList.remove('hidden');
             guestLogoutBtn.classList.add('hidden');
             // Кнопка отмены будет показана только после загрузки файла
             // revertBtn.classList.remove('hidden'); 
             
             // Сброс стилей 2x2
             editorButtonsContainer.classList.remove('guest-buttons-container-mobile');
             editorButtonsContainer.classList.add('flex-row', 'space-x-2');
        }
        
        // Прокрутка к редактору
        window.scrollTo({ top: 0, behavior: 'smooth' });
    }

    if (goToWhyUsBtn) {
        goToWhyUsBtn.addEventListener('click', (e) => {
            e.preventDefault(); 
            handleStartEditing(); 
        });
    }
    
    if (startEditingBtn) {
        startEditingBtn.addEventListener('click', (e) => {
            e.preventDefault();
            handleStartEditing(); 
        });
    }
    
    // Обработчик для новой кнопки "Начать редактирование" в карточке "Без регистрации"
    if (startNoRegBtn) {
        startNoRegBtn.addEventListener('click', (e) => {
             e.preventDefault();
             handleStartEditing();
        });
    }
    // *** КОНЕЦ ИЗМЕНЕНИЙ В ОБРАБОТТЧИКАХ КНОПОК ***


    async function loadPlaylistFromUrl(url, loadingElement, buttonElement) {
        if (!url) {
            showToast('Пожалуйста, введите ссылку');
            return;
        }
        
        // Гость не может загружать по ссылке (только файлом), так как это требует CORS-прокси
        if (isAnonymousUser) {
            showToast("Загрузка по прямой ссылке доступна только зарегистрированным пользователям.");
            return;
        }

        loadingElement.classList.remove('hidden');
        buttonElement.disabled = true;

        try {
            // Если загрузка идет из модального окна, скрываем его
            if (loadingElement === loadingModal) {
                dropAreaModal.classList.add('hidden');
            }

            const proxyUrl = 'https://corsproxy.io/?' + encodeURIComponent(url);
            const response = await fetch(proxyUrl);
            
            if (!response.ok) {
                throw new Error(`Ошибка HTTP: ${response.status}`);
            }
            
            loadingElement.classList.add('hidden');
            const content = await response.text();

            globalLoader.classList.remove('hidden');

            setTimeout(() => {
                // Загрузка по ссылке всегда считается слиянием
                processPlaylistContent(content, true); 
            }, 50);

        } catch (error) {
            console.error('Ошибка загрузки:', error);
            showToast('Не удалось загрузить файл. Возможно, проблема с CORS или файл недоступна.');
            loadingElement.classList.add('hidden');
        } finally {
            buttonElement.disabled = false;
            // Возвращаем видимость дроп-зоны, если она была скрыта
            if (loadingElement === loadingModal) {
                 dropAreaModal.classList.remove('hidden');
            }
        }
    }

    // *** ИЗМЕНЕННАЯ ФУНКЦИЯ processPlaylistContent ***
    function processPlaylistContent(content, isMerge = false) {
        
        const existingChannels = [...channels]; // Сохраняем текущие каналы
        const initialChannelCount = existingChannels.length;
        
        // *** НОВОЕ: Сохранение исходного состояния перед парсингом, если это не слияние ***
        // Если это не слияние (первая загрузка), то сохраняем оригинальные данные
        if (!isMerge || initialChannelCount === 0) {
             originalChannels = []; 
             originalCategories.clear();
             revertBtn.classList.add('hidden'); // Скрываем, пока не получим каналы
        }
        // ******************************************************************************

        channels = []; // Временно очищаем для парсинга
        allCategories.clear();
        categoryChannelCounts = {};
        originalLines = content.split('\n'); 

        parseChannelsAsync()
            .then(() => {
                globalLoader.classList.add('hidden');
                loadingModal.classList.add('hidden');
                dropAreaModal.classList.remove('hidden');
                uploadModal.classList.add('hidden');

                // 1. СЛИЯНИЕ: Добавляем ранее существующие каналы в начало списка
                if (isMerge && initialChannelCount > 0) {
                     // 1.1 Сохраняем статус избранного для старых каналов
                     const existingFavorites = new Map();
                     existingChannels.forEach(c => existingFavorites.set(c.url + c.name, c.isFavorite));
                     
                     // 1.2 Присваиваем статус избранного новым каналам, если они уже были в старом списке
                     channels.forEach(newC => {
                         const key = newC.url + newC.name;
                         if (existingFavorites.has(key)) {
                             newC.isFavorite = existingFavorites.get(key);
                             existingFavorites.delete(key); // Удаляем, чтобы не добавлять дубликаты
                         }
                     });
                     
                     // 1.3 Добавляем каналы, которых не было в новом списке (порядок сохранен)
                     channels = [...existingChannels, ...channels]; 
                }
                
                // 2. Дедупликация и пересборка категорий
                // Дедупликация должна вызываться всегда при слиянии, а также при обычной загрузке
                // (чтобы избежать дубликатов внутри одного файла)
                deduplicateChannels(); 
                rebuildCategoryData(); 
                
                // *** НОВОЕ: Сохранение исходного состояния, если это не было сделано ранее ***
                // Сохраняем "чистую" версию после дедупликации/первого слияния
                if (!isMerge || initialChannelCount === 0) {
                    originalChannels = JSON.parse(JSON.stringify(channels)); // Сохраняем "чистую" версию
                    originalCategories = new Set(allCategories);
                }
                
                // *** НОВОЕ: Показываем кнопку отмены после успешной загрузки ***
                if (channels.length > 0 && !isAnonymousUser) {
                     revertBtn.classList.remove('hidden');
                }
                // **************************************************************************
                
                // Переключаем экраны: основной скрываем, редактор показываем
                mainScreen.classList.add('hidden');
                editorScreen.classList.remove('hidden');
                
                // *** ПРОВЕРКА ДЛЯ УПРАВЛЕНИЕ КНОПКАМИ В РЕДАКТОРЕ ***
                if (isAnonymousUser) {
                    saveBtn.classList.remove('hidden'); 
                    openUploadModalBtn.classList.remove('hidden'); 
                    guestLogoutBtn.classList.remove('hidden');
                    revertBtn.classList.add('hidden'); // Скрываем отмену для гостя
                    
                    if (window.innerWidth <= 640) {
                        editorButtonsContainer.classList.add('guest-buttons-container-mobile');
                        editorButtonsContainer.classList.remove('flex-row', 'space-x-2');
                    } else {
                        editorButtonsContainer.classList.remove('guest-buttons-container-mobile');
                        editorButtonsContainer.classList.add('flex-row', 'space-x-2');
                    }
                } else {
                    saveBtn.classList.remove('hidden');
                    openUploadModalBtn.classList.remove('hidden');
                    guestLogoutBtn.classList.add('hidden');
                    // revertBtn.classList.remove('hidden'); // Уже сделано выше
                    
                    editorButtonsContainer.classList.remove('guest-buttons-container-mobile');
                    editorButtonsContainer.classList.add('flex-row', 'space-x-2');
                }
                // *** КОНЕЦ ПРОВЕРКИ ***
                
                excludedCategories.clear(); 
                renderCategoryFilter();
                renderCategorySelect();
                categorySelect.value = ""; 
                updateCounter(); // ИЗМЕНЕНИЕ: Вызов без аргументов
                renderChannelList();

                // УДАЛЕНА ИНИЦИАЛИЗАЦИЯ SortableJS
                
                const finalCount = channels.length;
                const newCount = finalCount - initialChannelCount;
                if (isMerge) {
                    showToast(`Успешно добавлено ${newCount} каналов. Всего: ${finalCount}.`); 
                } else {
                    showToast('Плейлист загружен.', finalCount);
                }

            })
            .catch(error => {
                globalLoader.classList.add('hidden');
                loadingModal.classList.add('hidden');
                dropAreaModal.classList.remove('hidden');
                showToast('Ошибка обработки файла: ' + error.message);
                
                // В случае ошибки возвращаем на главный экран
                mainScreen.classList.remove('hidden');
                editorScreen.classList.add('hidden');
            });
    }
    
    // *** НОВАЯ/ОБНОВЛЕННАЯ ВСПОМОГАТЕЛЬНАЯ ФУНКЦИЯ ДЛЯ СЛИЯНИЯ И ДЕДУПЛИКАЦИИ ***
    function rebuildCategoryData() {
        allCategories.clear();
        categoryChannelCounts = {};
        channels.forEach(entry => {
            allCategories.add(entry.category);
            categoryChannelCounts[entry.category] = (categoryChannelCounts[entry.category] || 0) + 1;
        });
        
        // Показываем кнопку отмены при любом изменении массива/категорий
        if (channels.length > 0 && !isAnonymousUser) {
             revertBtn.classList.remove('hidden');
        } else {
             revertBtn.classList.add('hidden');
        }
        
        // После перестройки данных перерендерим фильтры/селекты
        renderCategoryFilter();
        renderCategorySelect();
        renderChannelList(searchInput.value); // И перерендерим список
        updateCounter(); // Обновляем счетчик
    }

    function deduplicateChannels() {
        const uniqueMap = new Map(); // Key: URL + Name (lowercase, trimmed)
        const newChannels = [];
        let removedCount = 0;

        // Идем по порядку, чтобы сохранить первый найденный канал
        for (const channel of channels) {
            const key = (channel.url + channel.name).trim().toLowerCase();
            
            if (!uniqueMap.has(key)) {
                uniqueMap.set(key, true);
                newChannels.push(channel);
            } else {
                removedCount++;
            }
        }
        
        channels = newChannels;
        
        if (removedCount > 0) {
            showToast(`Автоматически удалено ${removedCount} дубликатов при обработке.`);
        }
        // Пересборка категорий будет запущена в processPlaylistContent после этого
    }
    // *** КОНЕЦ НОВЫХ ВСПОМОГАТЕЛЬНЫХ ФУНКЦИЙ ***

    // =======================================================
    // ФУНКЦИЯ ОТМЕНЫ ВСЕХ ИЗМЕНЕНИЙ
    // =======================================================
    function revertChanges() {
        if (isAnonymousUser) return;

        // Проверяем, есть ли вообще изменения
        // Простая проверка по длине и совпадению содержимого (не глубокое сравнение, но достаточно для UI)
        if (channels.length === originalChannels.length && 
            channels.every((c, i) => c.id === originalChannels[i].id)) 
        {
            showToast("Нет изменений для отмены.");
            return;
        }

        if (!confirm("Вы уверены, что хотите отменить ВСЕ изменения (порядок, удаление, добавление, переименование)?")) return;
        
        // 1. Восстанавливаем основной массив каналов (глубокое копирование)
        channels = JSON.parse(JSON.stringify(originalChannels)); 
        
        // 2. Восстанавливаем данные о категориях
        allCategories = new Set(originalCategories);
        excludedCategories.clear();
        categoryChannelCounts = {};
        channels.forEach(entry => {
            categoryChannelCounts[entry.category] = (categoryChannelCounts[entry.category] || 0) + 1;
        });

        // 3. Обновляем UI
        renderCategoryFilter();
        renderCategorySelect();
        categorySelect.value = ""; 
        searchInput.value = "";
        renderChannelList(searchInput.value);
        updateCounter(); 

        revertBtn.classList.add('hidden');
        showToast("Все изменения отменены. Плейлист восстановлен.");
    }

    revertBtn.addEventListener('click', revertChanges);
    // =======================================================


    // =======================================================
    // ФУНКЦИЯ ДЛЯ ИНИЦИАЛИЗАЦИИ SORTABLEJS (УДАЛЕНА)
    // =======================================================
    /* function initializeSortable() {
        // УДАЛЕНО: Функционал перетаскивания отключен
    } */
    
    // =======================================================
    // НОВАЯ ЛОГИКА ДЛЯ СТАНДАРТИЗАЦИИ ИМЕНИ КАНАЛА
    // =======================================================

    /**
     * Создает имя для поиска логотипа в базе, используя UPPERCASE и HD/SD.
     * Унифицирует имя канала, игнорируя регистр и распространенные разделители.
     * * @param {string} name - Исходное имя канала (например, "Viasat Sport HD").
     * @returns {string} - Имя для поиска (например, "VIASAT SPORT HD").
     */
    function getChannelSearchName(name) {
        if (!name) return '';

        // 1. Приведение к верхнему регистру, чтобы игнорировать регистр.
        let searchName = name.trim().toUpperCase();

        // 2. Унификация разделителей: заменяем распространенные разделители на пробел
        searchName = searchName.replace(/[\-/_.\s]/g, ' ').replace(/\s\s+/g, ' ').trim();
        
        // 3. Удаляем только те символы, которые могут быть "шумом"
        // (Осторожно с удалением, чтобы не удалить номера каналов, если они важны)
        // Для цели унификации регистр и пробелы уже обработаны.
        
        return searchName;
    }

    /**
     * Функция для формирования URL из имени файла (кодирует пробелы).
     * @param {string} n - Имя файла (например, "VIASAT SPORT HD").
     */
    const formatUrlName = (n) => n.trim().replace(/\s/g, '%20') + '.png';

    // =======================================================
    // ОБНОВЛЕННАЯ ЛОГИКА ПАРСИНГА С НОВЫМ getChannelSearchName
    // =======================================================

    function parseChannelsAsync() {
        return new Promise((resolve, reject) => {
            try {
                const lines = originalLines;
                const totalLines = lines.length;
                let currentIndex = 0;
                const chunkSize = 1000;

                function processChunk() {
                    const limit = Math.min(currentIndex + chunkSize, totalLines);

                    for (let i = currentIndex; i < limit; i++) {
                        const line = lines[i].trim();

                        if (line.startsWith('#EXTINF')) {
                            const extinf = line;
                            const nameMatch = extinf.match(/,(.*)$/);
                            let name = nameMatch ? nameMatch[1].trim() : 'Неизвестный канал';
                            
                            let category = 'Без категории';
                            const groupTitleMatch = extinf.match(/group-title="([^"]*)"/i);
                            if (groupTitleMatch) {
                                category = groupTitleMatch[1].trim();
                            }
                            
                            // *** НОВОЕ: Извлечение TVG-ID ***
                            let tvgId = '';
                            const tvgIdMatch = extinf.match(/tvg-id="([^"]*)"/i);
                            if (tvgIdMatch) {
                                tvgId = tvgIdMatch[1].trim();
                            }
                            // ********************************

                            let logoUrl = '';
                            const logoMatch = extinf.match(/tvg-logo="([^"]*)"/i);
                            if (logoMatch) {
                                // Приоритет 1: Использовать оригинальный tvg-logo
                                logoUrl = logoMatch[1].trim();
                            }
                            
                            // *** НОВАЯ ЛОГИКА: ИСПОЛЬЗУЕМ СТАНДАРТИЗИРОВАННОЕ ИМЯ ***
                            if (!logoUrl && name && name !== 'Неизвестный канал') {
                                
                                const searchName = getChannelSearchName(name); // Получаем VIASAT SPORT HD
                                
                                if (searchName) {
                                    // Формируем URL по стандартизированному имени
                                    const exactLogoUrl = DEFAULT_LOGO_BASE_URL + formatUrlName(searchName);
                                    
                                    logoUrl = exactLogoUrl;
                                }
                            }
                            // ************************************************


                            let url = '';
                            let extgrp = '';
                            let urlIndex = i + 1;

                            while (urlIndex < lines.length) {
                                const nextLine = lines[urlIndex].trim();
                                if (nextLine.startsWith('#EXTGRP:')) {
                                    if (category === 'Без категории' || category === '') {
                                        category = nextLine.substring(8).trim();
                                    }
                                    extgrp = nextLine;
                                } else if (nextLine && !nextLine.startsWith('#')) {
                                    url = nextLine;
                                    break;
                                } else if (nextLine.startsWith('#EXTINF')) {
                                    break; 
                                }
                                urlIndex++;
                            }

                            if (url) {
                                channels.push({
                                    id: Date.now() + Math.random().toString(36).substring(2, 9), 
                                    name, extinf, extgrp, url,
                                    startIndex: i,
                                    endIndex: urlIndex,
                                    category,
                                    logoUrl, 
                                    tvgId, // <--- НОВЫЙ TVG-ID (сохраняем оригинальный, если есть)
                                    isFavorite: false,
                                    isSelected: false,
                                });
                                i = urlIndex;
                            }
                        }
                    }

                    currentIndex = limit;

                    if (currentIndex < totalLines) {
                        setTimeout(processChunk, 0);
                    } else {
                        resolve();
                    }
                }

                processChunk();
            } catch (error) {
                reject(error);
            }
        });
    }
    
    // Вспомогательная функция, чтобы не дублировать логику фильтрации
    function getFilteredChannels(filter = '', selectedCategory = '') {
        let filteredChannels = channels;

        // 1. Фильтрация по исключенным категориям
        filteredChannels = filteredChannels.filter(entry => !excludedCategories.has(entry.category));

        // 2. Фильтрация по Избранному (если выбрано)
        if (selectedCategory === FAVORITE_CATEGORY) {
            filteredChannels = filteredChannels.filter(entry => entry.isFavorite);
        } else if (excludedCategories.has(FAVORITE_CATEGORY)) {
            filteredChannels = filteredChannels.filter(entry => !entry.isFavorite);
        }

        // 3. Фильтрация по поиску
        filteredChannels = filteredChannels
            .filter(entry => entry.name.toLowerCase().includes(filter.toLowerCase()))
            .filter(entry => !selectedCategory || selectedCategory === FAVORITE_CATEGORY || entry.category === selectedCategory);
            
        // 4. Сортировка
        const sortType = sortSelect.value;
        if (sortType === 'name') {
            filteredChannels.sort((a, b) => a.name.localeCompare(b.name));
        } else if (sortType === 'category') {
             filteredChannels.sort((a, b) => a.category.localeCompare(b.category));
        }
            
        return filteredChannels;
    }
    
    // ОБРАБОТЧИК ДЛЯ СОРТИРОВКИ
    sortSelect.addEventListener('change', () => {
        renderChannelList(searchInput.value);
    });

    function getFavoriteCount() { 
        return channels.filter(c => c.isFavorite).length;
    }
    
    function updateMassEditControls() {
        const selectedCount = channels.filter(c => c.isSelected).length;
        selectedChannelCount.textContent = selectedCount;
        if (selectedCount > 0) {
             massEditControls.classList.remove('hidden');
        } else {
             massEditControls.classList.add('hidden');
        }
    }
    
    selectAllCheckbox.addEventListener('change', (e) => {
        const isChecked = e.target.checked;
        
        // Выбираем или снимаем выбор со всех отображаемых каналов
        const visibleChannels = getFilteredChannels(searchInput.value, categorySelect.value);
        visibleChannels.forEach(channel => {
            channel.isSelected = isChecked;
        });
        
        // Перерендерим список, чтобы чекбоксы обновились
        renderChannelList(searchInput.value);
    });

    // Обработчик для изменения категории выбранных каналов
    openRenameCategoryModalMassBtn.addEventListener('click', () => {
        const selectedCount = channels.filter(c => c.isSelected).length;
        if (selectedCount === 0) {
            showToast("Сначала выберите каналы.");
            return;
        }
        
        // Переиспользуем модальное окно, но заполняем его иначе
        oldCategorySelect.innerHTML = '<option value="">(Все выбранные каналы)</option>';
        newCategoryName.placeholder = 'Новая категория для выбранных каналов';
        submitRenameCategoryBtn.textContent = 'ИЗМЕНИТЬ КАТЕГОРИИ';
        
        // Меняем обработчик, чтобы он выполнял массовое изменение, а не переименование
        submitRenameCategoryBtn.onclick = () => {
            const newCat = newCategoryName.value.trim();
            if (!newCat) {
                showToast("Введите название новой категории.");
                return;
            }
            
            channels.forEach(channel => {
                if (channel.isSelected) {
                    channel.category = newCat;
                    channel.isSelected = false; // Снимаем выделение
                }
            });
            
            // Обновляем UI
            rebuildCategoryData(); 
            updateMassEditControls(); 
            renameCategoryModal.classList.add('hidden');
            showToast(`Категория изменена для ${selectedCount} каналов.`);
        };
        
        renameCategoryModal.classList.remove('hidden');
        newCategoryName.value = '';
    });
    
    // Обработчик для удаления выбранных каналов
    deleteSelectedBtn.addEventListener('click', () => {
        const selectedCount = channels.filter(c => c.isSelected).length;
        if (selectedCount === 0) return;

        if (!confirm(`Вы уверены, что хотите удалить ${selectedCount} выбранных каналов?`)) return;

        channels = channels.filter(c => !c.isSelected);

        rebuildCategoryData(); 
        updateMassEditControls();
        selectAllCheckbox.checked = false; 
        showToast(`Удалено ${selectedCount} каналов.`);
    });


    function renderCategoryFilter() {
      categoryFilter.innerHTML = '';
      const sortedCategories = Array.from(allCategories).sort();

      const favoriteCount = getFavoriteCount(); 
      
      if (favoriteCount > 0 || excludedCategories.has(FAVORITE_CATEGORY)) {
          sortedCategories.unshift(FAVORITE_CATEGORY);
          categoryChannelCounts[FAVORITE_CATEGORY] = favoriteCount;
      }

      sortedCategories.forEach(category => {
        const container = document.createElement('label');
        container.className = 'flex items-center space-x-2 bg-white px-3 py-1 rounded-full shadow-sm cursor-pointer hover:bg-gray-100 transition text-sm';

        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.className = 'form-checkbox h-4 w-4 text-black rounded border-gray-300 focus:ring-0';
        checkbox.value = category;
        checkbox.checked = excludedCategories.has(category);
        
        checkbox.addEventListener('change', (e) => {
          if (e.target.checked) {
            excludedCategories.add(category);
          } else {
            excludedCategories.delete(category);
          }
          renderChannelList(searchInput.value); 
        });

        const span = document.createElement('span');
        const count = categoryChannelCounts[category] || 0;
        span.className = 'text-gray-800 truncate max-w-[150px]';
        span.innerHTML = `${category} (<span class="text-red-600 font-bold">${count}</span>)`;

        container.appendChild(checkbox);
        container.appendChild(span);
        categoryFilter.appendChild(container);
      });
    }
    
    function renderCategorySelect() {
        categorySelect.innerHTML = '<option value="">Все категории</option>';
        const sortedCategories = Array.from(allCategories).sort();
        
        const favoriteCount = getFavoriteCount(); 
        
        if (favoriteCount > 0) { 
             sortedCategories.unshift(FAVORITE_CATEGORY);
             categoryChannelCounts[FAVORITE_CATEGORY] = favoriteCount;
        }

        sortedCategories.forEach(category => {
            const option = document.createElement('option');
            option.value = category;
            const count = categoryChannelCounts[category] || 0;
            option.textContent = `${category} (${count})`;
            categorySelect.appendChild(option);
        });
        
        // Обновляем список для переименования
        renderRenameCategorySelect();
    }
    
    // *** НОВАЯ ФУНКЦИЯ ДЛЯ МОДАЛЬНОГО ОКНА ПЕРЕИМЕНОВАНИЯ КАТЕГОРИЙ ***
    function renderRenameCategorySelect() {
        oldCategorySelect.innerHTML = '<option value="">Выберите категорию</option>';
        // Исключаем Избранное и Без категории из переименования
        const categoriesToRename = Array.from(allCategories).filter(cat => cat !== 'Без категории').sort();
        
        categoriesToRename.forEach(category => {
            const option = document.createElement('option');
            option.value = category;
            option.textContent = category;
            oldCategorySelect.appendChild(option);
        });
    }

    // ОБРАБОТЧИК КНОПКИ ПЕРЕИМЕНОВАНИЯ
    openRenameCategoryModalBtn.addEventListener('click', () => {
        if (isAnonymousUser) {
             showToast("Функция переименования категории доступна только зарегистрированным пользователям.");
             registrationModal.classList.remove('hidden');
             return;
        }
        // Сброс настроек для переименования одной категории
        oldCategorySelect.innerHTML = '<option value="">Выберите категорию</option>';
        newCategoryName.placeholder = 'Новое название категории';
        submitRenameCategoryBtn.textContent = 'ПЕРЕИМЕНОВАТЬ';
        
        // Устанавливаем правильный обработчик
        submitRenameCategoryBtn.onclick = handleCategoryRename;
        
        renderRenameCategorySelect();
        renameCategoryModal.classList.remove('hidden');
        newCategoryName.value = '';
    });
    
    closeRenameCategoryModal.addEventListener('click', () => {
        renameCategoryModal.classList.add('hidden');
    });

    function handleCategoryRename() {
        const oldCat = oldCategorySelect.value;
        const newCat = newCategoryName.value.trim();

        if (!oldCat || !newCat) {
            showToast("Выберите категорию и введите новое имя.");
            return;
        }

        if (oldCat === newCat) {
            showToast("Новое имя должно отличаться от старого.");
            return;
        }

        let renamedCount = 0;
        channels.forEach(channel => {
            if (channel.category === oldCat) {
                channel.category = newCat;
                renamedCount++;
            }
        });
        
        if (renamedCount > 0) {
            // Удаляем старую категорию, так как она пуста
            allCategories.delete(oldCat);
            
            // Добавляем или обновляем новую
            allCategories.add(newCat);
            
            // Перестраиваем все данные и перерендериваем UI
            rebuildCategoryData(); 
            
            renameCategoryModal.classList.add('hidden');
            showToast(`Категория изменена для ${renamedCount} каналов.`);
        } else {
             showToast(`Каналы в категории "${oldCat}" не найдены.`);
        }
    }
    // *** КОНЕЦ НОВЫХ ФУНКЦИЙ ДЛЯ ПЕРЕИМЕНОВАНИЯ КАТЕГОРИЙ ***

    categorySelect.addEventListener('change', () => {
        renderChannelList(searchInput.value);
    });

    // [СКАЧИВАНИЕ: ИЗМЕНЕНИЕ] Обновленная функция для включения лого
    function downloadSingleChannel(entry) {
        
      if (isAnonymousUser && saveModal.classList.contains('hidden') === false) {
           saveModal.classList.add('hidden'); // Скрываем модалку сохранения, если она открыта
      }
        
      let playlistContent = `#EXTM3U\n`;
      
      // Формируем строку EXTINF с актуальным лого и TVG-ID
      let extinfLine = `#EXTINF:-1`;
      // *** ИСПРАВЛЕНО: Автоматически использовать Название Канала, если tvgId пуст (даже для авторизованных) ***
      const finalTvgId = entry.tvgId || entry.name; 
      extinfLine += ` tvg-id="${finalTvgId}"`;
      // **********************************************************************************************************

      extinfLine += ` group-title="${entry.category}"`;
      if (entry.logoUrl) {
          extinfLine += ` tvg-logo="${entry.logoUrl}"`;
      }
      extinfLine += `,${entry.name}`;
      
      playlistContent += `${extinfLine}\n`;
      
      if (entry.extgrp) {
        playlistContent += `${entry.extgrp}\n`;
      }
      playlistContent += `${entry.url}`;

      const blob = new Blob([playlistContent], { type: 'text/plain;charset=utf-8' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `${entry.name.replace(/[^a-zA-Z0-9а-яА-Я]/g, '_')}.m3u`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }
    // [СКАЧИВАНИЕ: КОНЕЦ ИЗМЕНЕНИЯ]


    function toggleFavorite(entry) {
        // Гость не может использовать Избранное, так как нет сохранения
        if (isAnonymousUser) {
             showToast("Функция 'Избранное' доступна только зарегистрированным пользователям.");
             registrationModal.classList.remove('hidden');
             return;
        }

        entry.isFavorite = !entry.isFavorite; 

        rebuildCategoryData(); // Перестраиваем, чтобы обновить счетчики и селекты
        
        const action = entry.isFavorite ? 'добавлен в' : 'удален из';
        showToast(`Канал "${entry.name}" ${action} избранного.`);
    }
    
    // [ПЕРЕИМЕНОВАТЬ: НОВОЕ] Логика переименования канала
    function openRenameChannelModal(entry) {
        if (isAnonymousUser) {
             showToast("Функция переименования канала доступна только зарегистрированным пользователям.");
             registrationModal.classList.remove('hidden');
             return;
        }

        currentChannelToRename = entry;
        renamedChannelName.value = entry.name;
        renameChannelModal.classList.remove('hidden');
    }

    closeRenameChannelModal.addEventListener('click', () => {
        renameChannelModal.classList.add('hidden');
    });

    submitRenameChannelBtn.addEventListener('click', () => {
        if (!currentChannelToRename) return;

        const newName = renamedChannelName.value.trim();
        if (!newName) {
            showToast("Введите новое название канала.");
            return;
        }
        
        const oldName = currentChannelToRename.name;
        
        // 1. Обновляем имя канала в объекте
        currentChannelToRename.name = newName;
        
        // 2. Обновляем строку EXTINF с новым именем и, при необходимости, логотипом и TVG-ID
        let extinfLine = `#EXTINF:-1`;
        // *** ИСПРАВЛЕНО: Автоматически использовать Название Канала, если tvgId пуст ***
        const finalTvgId = currentChannelToRename.tvgId || newName; 
        extinfLine += ` tvg-id="${finalTvgId}"`;
        // ******************************************************************************

        extinfLine += ` group-title="${currentChannelToRename.category}"`;
        
        // 3. Сбрасываем/пересчитываем logoUrl, чтобы убедиться, что он соответствует новому имени
        // Используем новую логику стандартизации
        let updatedLogoUrl = '';
        const searchName = getChannelSearchName(newName);
        
        if (searchName) {
            updatedLogoUrl = DEFAULT_LOGO_BASE_URL + formatUrlName(searchName);
        }
        
        currentChannelToRename.logoUrl = updatedLogoUrl;
        
        // Добавляем обновленный логотип в строку EXTINF
        if (updatedLogoUrl) {
            extinfLine += ` tvg-logo="${updatedLogoUrl}"`;
        }
        
        extinfLine += `,${newName}`;
        currentChannelToRename.extinf = extinfLine;
        
        
        // 4. Обновляем UI
        rebuildCategoryData(); // Перестройка нужна, если имя используется в сортировке/фильтре (хотя тут не используется)
        renameChannelModal.classList.add('hidden');
        currentChannelToRename = null;
        showToast(`Канал "${oldName}" переименован в "${newName}".`);
    });
    // [ПЕРЕИМЕНОВАТЬ: КОНЕЦ НОВОГО]
    
    // *** НОВАЯ ФУНКЦИЯ ДЛЯ ДОБАВЛЕНИЯ КАНАЛА ***
    addChannelBtn.addEventListener('click', () => {
        if (isAnonymousUser) {
             showToast("Функция 'Добавить канал' доступна только зарегистрированным пользователям.");
             registrationModal.classList.remove('hidden');
             return;
        }
        // Сброс полей
        newChannelName.value = '';
        newChannelCategory.value = '';
        newChannelUrl.value = '';
        // [ЛОГО: ИЗМЕНЕНИЕ] Сброс поля лого
        newChannelLogoUrl.value = ''; 
        // [ЛОГО: КОНЕЦ ИЗМЕНЕНИЯ]
        addChannelModal.classList.remove('hidden');
    });

    closeAddChannelModal.addEventListener('click', () => {
        addChannelModal.classList.add('hidden');
    });

    submitNewChannelBtn.addEventListener('click', () => {
        const name = newChannelName.value.trim();
        const category = newChannelCategory.value.trim() || 'Без категории';
        const url = newChannelUrl.value.trim();
        // [ЛОГО: ИЗМЕНЕНИЕ] Получение URL логотипа
        const customLogoUrl = newChannelLogoUrl.value.trim(); 
        
        if (!name || !url) {
            showToast("Пожалуйста, введите Название и URL канала.");
            return;
        }
        
        let finalLogoUrl = customLogoUrl;
        
        // Если кастомный логотип не указан, формируем его по правилу стандартизации
        if (!finalLogoUrl) {
            const searchName = getChannelSearchName(name);
            finalLogoUrl = DEFAULT_LOGO_BASE_URL + formatUrlName(searchName);
        }
        
        // Формируем EXTINF с атрибутом tvg-logo и tvg-id (будет равно Названию Канала)
        let extinf = `#EXTINF:-1 tvg-id="${name}" group-title="${category}"`; // <--- ИЗМЕНЕНО
        if (finalLogoUrl) {
            extinf += ` tvg-logo="${finalLogoUrl}"`;
        }
        extinf += `,${name}`;
        // [ЛОГО: КОНЕЦ ИЗМЕНЕНИЯ]
        
        const extgrp = `#EXTGRP:${category}`;
        
        const newChannel = {
            id: Date.now() + Math.random().toString(36).substring(2, 9), 
            name, extinf, extgrp, url,
            startIndex: -1, // Временно, будет обновлено при сохранении
            endIndex: -1,
            category,
            logoUrl: finalLogoUrl, // [ЛОГО: ИЗМЕНЕНИЕ] Сохранение URL лого
            tvgId: name, // НОВЫЙ TVG-ID (равен названию)
            isFavorite: false,
            isSelected: false,
        };
        
        // Добавляем в начало списка
        channels.unshift(newChannel); 
        
        rebuildCategoryData(); 
        addChannelModal.classList.add('hidden');
        showToast(`Канал "${name}" успешно добавлен.`);
    });
    // *** КОНЕЦ ФУНКЦИЙ ДЛЯ ДОБАВЛЕНИЯ КАНАЛА ***


    function renderChannelList(filter = '') {
      channelList.innerHTML = '';
      
      const isMobile = window.matchMedia('(max-width: 640px)').matches;
      const downloadButtonText = isMobile ? 'Скачать' : 'Скачать канал';
      
      const selectedCategory = categorySelect.value; 
      
      let filteredChannels = getFilteredChannels(filter, selectedCategory);

      updateCounter(filteredChannels.length); 
      
      // Скрываем/показываем чекбокс "Выбрать все"
      if (filteredChannels.length > 0) {
          selectAllContainer.classList.remove('hidden');
      } else {
          selectAllContainer.classList.add('hidden');
      }
        
      filteredChannels.forEach((entry, index) => {
          const item = document.createElement('div');
          // Удален класс sortable-channel
          const guestModeClass = isAnonymousUser ? 'guest-mode' : '';
          item.className = `channel-item flex items-center justify-between bg-gray-100 px-4 py-2 rounded-xl shadow ${guestModeClass}`; 
          item.dataset.channelId = entry.id; 
          
          // *** ЧЕКБОКС И НУМЕРАЦИЯ КАНАЛА ***
          const contentWrapper = document.createElement('div');
          contentWrapper.className = 'channel-item-content';
          
          const checkbox = document.createElement('input');
          checkbox.type = 'checkbox';
          checkbox.className = 'channel-checkbox form-checkbox h-5 w-5 text-black rounded border-gray-400 focus:ring-0';
          checkbox.checked = entry.isSelected;
          checkbox.addEventListener('change', (e) => {
               entry.isSelected = e.target.checked;
               updateMassEditControls();
               // Если сняли выбор с одного, снимаем с "Выбрать все"
               if (!e.target.checked) {
                   selectAllCheckbox.checked = false;
               } else {
                   // Если все на странице выбраны, ставим галочку на "Выбрать все"
                   const allSelected = filteredChannels.every(c => c.isSelected);
                   if (allSelected) selectAllCheckbox.checked = true;
               }
          });

          const number = document.createElement('span');
          number.className = 'channel-number';
          number.textContent = index + 1; // Нумерация с 1

          // [ЛОГО: ИЗМЕНЕНИЕ] Добавление элемента для логотипа.
          const logo = document.createElement('img');
          logo.className = 'channel-logo';
          
          // Если у канала есть logoUrl (сформированный или оригинальный) - используем его.
          // Если logoUrl пуст, используем прозрачную заглушку, чтобы сохранить место.
          if (entry.logoUrl) {
             logo.src = entry.logoUrl;
          } else {
             // Используем пустую, прозрачную заглушку, чтобы сохранить место и не ломать верстку
             logo.src = 'data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="transparent"></svg>'; 
          }
          
          logo.alt = 'Логотип канала';
          // [ЛОГО: КОНЕЦ ИЗМЕНЕНИЯ]
          
          const name = document.createElement('span');
          name.className = 'channel-name text-black font-medium'; 
          name.textContent = entry.name;

          contentWrapper.appendChild(checkbox);
          contentWrapper.appendChild(number);
          // [ЛОГО: ИЗМЕНЕНИЕ] Добавление логотипа
          contentWrapper.appendChild(logo); 
          // [ЛОГО: КОНЕЦ ИЗМЕНЕНИЯ]
          contentWrapper.appendChild(name);
          // *** КОНЕЦ ЧЕКБОКСА И НУМЕРАЦИИ КАНАЛА ***

          const favBtn = document.createElement('button');
          const starColor = entry.isFavorite ? 'text-yellow-500 hover:text-yellow-400' : 'text-gray-400 hover:text-yellow-500';
          favBtn.className = `channel-favorite-btn ${starColor} font-semibold text-xl px-2 py-1 transition flex-shrink-0`;
          favBtn.innerHTML = '★'; 
          favBtn.title = entry.isFavorite ? 'Удалить из избранного' : 'Добавить в избранное';
          favBtn.onclick = () => toggleFavorite(entry);
          
          // Скрываем кнопку избранного для гостя
          if (isAnonymousUser) {
             favBtn.classList.add('hidden');
          }


          const downloadBtn = document.createElement('button');
          downloadBtn.className = 'channel-download-btn bg-green-600 hover:bg-green-500 text-white font-semibold text-sm px-3 py-1 rounded-lg transition';
          downloadBtn.textContent = downloadButtonText;
          downloadBtn.onclick = () => downloadSingleChannel(entry);
          
          // ПОКАЗЫВАЕМ КНОПКУ "СКАЧАТЬ КАНАЛ" ТОЛЬКО ДЛЯ АВТОРИЗОВАННЫХ
          if (isAnonymousUser) {
              downloadBtn.classList.add('hidden');
          } else {
              downloadBtn.classList.remove('hidden');
          }
          
          // [ПЕРЕИМЕНОВАТЬ: НОВОЕ] Кнопка Переименовать
          const renameBtn = document.createElement('button');
          renameBtn.className = 'channel-rename-btn bg-yellow-500 hover:bg-yellow-600 text-white font-semibold text-sm px-3 py-1 rounded-lg transition';
          renameBtn.textContent = 'Переим.';
          renameBtn.onclick = () => openRenameChannelModal(entry);
          
          // Скрываем кнопку для гостя
          if (isAnonymousUser) {
              renameBtn.classList.add('hidden');
          }
          // [ПЕРЕИМЕНОВАТЬ: КОНЕЦ НОВОГО]


          const delBtn = document.createElement('button');
          delBtn.className = 'channel-delete-btn text-red-600 hover:text-red-500 font-semibold text-sm';
          delBtn.textContent = 'Удалить';
          
          // **********************************************
          // ИСПРАВЛЕНИЕ: НАДЕЖНОЕ УДАЛЕНИЕ КАНАЛА ИЗ МАССИВА
          // **********************************************
          delBtn.onclick = () => {
            const indexToDelete = channels.findIndex(c => c === entry);
            
            if (indexToDelete !== -1) {
              // Удаляем канал из основного массива channels
              channels.splice(indexToDelete, 1); 
              
              // Обновляем все UI-элементы
              rebuildCategoryData(); // ОБНОВЛЕНО: Пересборка данных о категориях
              showToast(`Канал "${entry.name}" удален.`);
            }
            
            // Важно: originalLines больше не изменяется напрямую при удалении канала.
            // Он будет пересоздан при сохранении плейлиста.
          };
          // **********************************************

          const buttonContainer = document.createElement('div');
          // Используем стандартный класс, а логика выравнивания меняется в CSS media-query
          buttonContainer.className = 'channel-buttons-container flex items-center gap-2 flex-shrink-0';
          
          // Добавляем кнопки в контейнер, учитывая их видимость
          buttonContainer.appendChild(favBtn); 
          buttonContainer.appendChild(renameBtn); // [ПЕРЕИМЕНОВАТЬ: НОВОЕ] Добавляем кнопку
          buttonContainer.appendChild(downloadBtn);
          buttonContainer.appendChild(delBtn);

          item.appendChild(contentWrapper); // Добавляем обертку с нумерацией и именем
          item.appendChild(buttonContainer);
          channelList.appendChild(item);
        });
        
        // Обновляем контролы массового редактирования при перерендеринге
        updateMassEditControls();
    }
    
    // Обновляем parseChannelsSync, чтобы она не сортировала, если это не удаление.
    function parseChannelsSync(maintainOrder = false) {
      // Эта функция сейчас используется только для дедупликации,
      // где originalLines были изменены, или при первоначальной загрузке.
      // Логика оставлена для совместимости, но не должна использоваться для основного рендеринга.
      
      const tempFavoriteMap = {};
      channels.forEach(c => {
        if (c.isFavorite) {
            tempFavoriteMap[c.url + c.name] = true; 
        }
      });
        
      channels = [];
      allCategories.clear();
      categoryChannelCounts = {};
      
      for (let i = 0; i < originalLines.length; i++) {
        const line = originalLines[i].trim();
        if (line.startsWith('#EXTINF')) {
          const extinf = line;
          const nameMatch = extinf.match(/,(.*)$/);
          let name = nameMatch ? nameMatch[1].trim() : 'Неизвестный канал';
          let category = 'Без категории';
          const groupTitleMatch = extinf.match(/group-title="([^"]*)"/i);
          if (groupTitleMatch) {
            category = groupTitleMatch[1].trim();
          }

          // *** НОВОЕ: Извлечение TVG-ID ***
          let tvgId = '';
          const tvgIdMatch = extinf.match(/tvg-id="([^"]*)"/i);
          if (tvgIdMatch) {
              tvgId = tvgIdMatch[1].trim();
          }
          // ********************************

          // [ЛОГО: ИЗМЕНЕНИЕ] Извлечение атрибута tvg-logo
          let logoUrl = '';
          const logoMatch = extinf.match(/tvg-logo="([^"]*)"/i);
          if (logoMatch) {
              logoUrl = logoMatch[1].trim();
          }
          
          // *** НОВАЯ ЛОГИКА: ИСПОЛЬЗУЕМ СТАНДАРТИЗИРОВАННОЕ ИМЯ ***
          if (!logoUrl && name && name !== 'Неизвестный канал') {
              
              const searchName = getChannelSearchName(name);
              
              if (searchName) {
                  const exactLogoUrl = DEFAULT_LOGO_BASE_URL + formatUrlName(searchName);
                  logoUrl = exactLogoUrl;
              }
          }
          // ************************************************
          
          let url = '';
          let extgrp = '';
          let urlIndex = i + 1;
          while (urlIndex < originalLines.length) {
            const nextLine = originalLines[urlIndex].trim(); 
            if (nextLine.startsWith('#EXTGRP:')) {
              if (category === 'Без категории' || category === '') {
                category = nextLine.substring(8).trim();
              }
              extgrp = nextLine;
            } else if (nextLine && !nextLine.startsWith('#')) {
              url = nextLine;
              break;
            } else if (nextLine.startsWith('#EXTINF')) {
              break;
            }
            urlIndex++;
          }
          if (url) {
            const key = url + name;
            const isFav = tempFavoriteMap[key] || false; 

            channels.push({
              id: Date.now() + Math.random().toString(36).substring(2, 9), 
              name, extinf, extgrp, url,
              startIndex: i,
              endIndex: urlIndex,
              category,
              logoUrl, // [ЛОГО: ИЗМЕНЕНИЕ] Сохранение URL лого
              tvgId, // НОВЫЙ TVG-ID
              isFavorite: isFav, 
              isSelected: false,
            });
            allCategories.add(category);
            categoryChannelCounts[category] = (categoryChannelCounts[category] || 0) + 1;
            i = urlIndex;
          }
        }
      }
    }


    // ИЗМЕНЕННАЯ ФУНКЦИЯ updateCounter
    function updateCounter(filteredCount = null) {
      
      const remainingChannels = channels.filter(entry => {
        const isNormalCategoryExcluded = excludedCategories.has(entry.category);
        const isFavoriteCategoryExcluded = excludedCategories.has(FAVORITE_CATEGORY);
        const isFavorite = entry.isFavorite;

        if (isFavorite) {
            return !isFavoriteCategoryExcluded;
        }
        
        return !isNormalCategoryExcluded;
      });
      
      const totalActiveCount = remainingChannels.length;
        
      // Всегда обновляем счетчик в заголовке, показывая общее количество активных каналов
      if (editorChannelCounter) {
          editorChannelCounter.textContent = `(${totalActiveCount})`;
      }
    }

    searchInput.addEventListener('input', () => {
      renderChannelList(searchInput.value);
    });

    function removeDuplicates() {
        const initialCount = channels.length;
        deduplicateChannels(); 
        const removedCount = initialCount - channels.length;
        
        if (removedCount > 0) {
            rebuildCategoryData(); 
            showToast(`Удалено ${removedCount} дубликатов каналов.`); 
        } else {
            showToast('Дубликаты каналов не найдены.'); 
        }
    }
    
    removeDuplicatesBtn.addEventListener('click', removeDuplicates);
    
    // =======================================================
    // ФУНКЦИИ СЕРВЕРНОГО СОХРАНЕНИЯ И СОКРАЩЕНИЯ ССЫЛКИ
    // =======================================================

    async function shortenDynamicLink(longUrl) {
        const apiUrl = `https://is.gd/create.php?format=json&url=${encodeURIComponent(longUrl)}`;
        
        try {
            const response = await fetch(apiUrl);
            const data = await response.json();
            
            if (data.shorturl) {
                return data.shorturl;
            } else {
                console.error('is.gd Error:', data.errormessage || 'Unknown error');
                showToast(`Ошибка сокращения ссылки: ${data.errormessage || 'Сбой API.'}`);
                return longUrl; // Вернуть длинную ссылку в случае ошибки
            }
        } catch (error) {
            console.error('Fetch Error:', error);
            showToast('⚠️ Ошибка соединения с is.gd.');
            return longUrl; // Вернуть длинную ссылку в случае сбоя сети
        }
    }

    async function uploadPlaylistToGitHub(content, count, persistentUserId) {
        // Проверка: теперь аутентификация обязательна
        if (auth.currentUser?.isAnonymous) {
            console.error("Attempted server upload as guest. This should not happen.");
            showToast("Ошибка: Сохранение на сервере требует входа.");
            return; 
        }

        const uploadUrl = '/.netlify/functions/save-playlist'; 
        
        try {
            // Файл будет сохранен под этим постоянным именем, обеспечивая динамическую ссылку.
            const permanentFilename = `playlist_${persistentUserId}_latest.m3u`;
            
            const response = await fetch(uploadUrl, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    filename: permanentFilename, // Передаем постоянное имя
                    fileContent: content, 
                    userId: userId,
                }),
            });
            
            if (!response.ok) {
                const errorData = await response.json();
                throw new Error(errorData.details || errorData.error || 'Unknown API Error');
            }
            
            // Если запрос успешен, то плейлист обновлен по динамической ссылке
            // showToast(`Плейлист обновлен на сервере. (${count} каналов)`); // УДАЛЕНО УВЕДОМЛЕНИЕ
            
        } catch (error) {
            console.error('Ошибка сохранения:', error);
            showToast(`Ошибка сохранения на сервере: ${error.message}`);
        }
    }

    // =======================================================
    // ФОРМИРОВАНИЕ КОНТЕНТА ПЛЕЙЛИСТА (ОБНОВЛЕНО ДЛЯ ЛОГО И EPG)
    // =======================================================
    function generatePlaylistContent(format) {
        const includedChannels = channels.filter(entry => {
            const isNormalCategoryExcluded = excludedCategories.has(entry.category);
            const isFavoriteCategoryExcluded = excludedCategories.has(FAVORITE_CATEGORY);
            const isFavorite = entry.isFavorite;

            if (isFavorite) {
                return !isFavoriteCategoryExcluded;
            }
            
            return !isNormalCategoryExcluded;
        });
        
        let modifiedLines = [];
        
        // Добавляем заголовок #EXTM3U, если это не TXT
        if (format !== 'txt') {
             modifiedLines.push(`#EXTM3U`);
             
             // *** ДОБАВЛЕНИЕ ССЫЛКИ НА EPG ***
             if (EPG_URL) {
                 // Используем x-tvg-url для лучшей совместимости
                 modifiedLines.push(`#EXTM3U x-tvg-url="${EPG_URL}"`); 
             }
             // ***************************************
        }

        const favoriteChannels = includedChannels.filter(c => c.isFavorite);
        
        // Добавление избранного (только для авторизованных)
        if (favoriteChannels.length > 0 && !isAnonymousUser) { 
            if (format !== 'txt') { // Добавляем группировку, если это не TXT
               modifiedLines.push(`#EXTGRP:${DISPLAY_FAVORITE_CATEGORY}`); 
            }
            
            favoriteChannels.forEach(entry => {
                
                // [ЛОГО: ИЗМЕНЕНИЕ] Пересборка EXTINF для Избранного (чтобы обновить tvg-logo и tvg-id)
                let favExtinf = `#EXTINF:-1`;
                
                // *** ИСПРАВЛЕНО: Автоматически использовать Название Канала, если tvgId пуст ***
                const finalTvgId = entry.tvgId || entry.name; 
                favExtinf += ` tvg-id="${finalTvgId}"`;
                // ******************************************************************************
                
                // Добавляем TVG-Logo
                if (entry.logoUrl) {
                    favExtinf += ` tvg-logo="${entry.logoUrl}"`;
                }
                favExtinf += ` group-title="${DISPLAY_FAVORITE_CATEGORY}",${entry.name}`;
                
                if (format !== 'txt') {
                    modifiedLines.push(favExtinf);
                } else {
                     // Для TXT просто добавляем оригинальные теги
                     if (entry.extinf) modifiedLines.push(entry.extinf);
                     if (entry.extgrp) modifiedLines.push(entry.extgrp);
                }
                // [ЛОГО: КОНЕЦ ИЗМЕНЕНИЯ]
                
                modifiedLines.push(entry.url);
            });
            
            if (format !== 'txt') {
                modifiedLines.push('');
            } else {
                // Если TXT, добавляем разделитель после группы избранного (если она есть)
                if (favoriteChannels.length > 0) modifiedLines.push('');
            }
        }
        
        const groupedChannels = {};
        includedChannels.forEach(entry => {
            if (entry.isFavorite && !isAnonymousUser) return;
            
            const cat = entry.category || 'Без категории';
            if (!groupedChannels[cat]) {
                groupedChannels[cat] = [];
            }
            groupedChannels[cat].push(entry);
        });
        
        const sortedCategories = Object.keys(groupedChannels).filter(cat => cat !== FAVORITE_CATEGORY).sort();
        
        sortedCategories.forEach(cat => {
            // Добавляем EXTGRP
            if (cat !== 'Без категории') {
                // Если это не TXT, используем EXTGRP для группировки
                if (format !== 'txt') {
                    modifiedLines.push(`#EXTGRP:${cat}`);
                } else {
                     // Для TXT добавляем EXTGRP (если он не был в самом EXTINF)
                     // Примечание: Для TXT мы добавляем EXTGRP только для категории.
                     modifiedLines.push(`#EXTGRP:${cat}`);
                }
            }

            groupedChannels[cat].forEach(entry => {
                
                // [ЛОГО: ИЗМЕНЕНИЕ] Пересборка EXTINF для обычной категории
                let extinfLine = `#EXTINF:-1`;
                
                 // *** ИСПРАВЛЕНО: Автоматически использовать Название Канала, если tvgId пуст ***
                const finalTvgId = entry.tvgId || entry.name; 
                extinfLine += ` tvg-id="${finalTvgId}"`;
                // ******************************************************************************
                
                // Добавляем TVG-Logo
                if (entry.logoUrl) {
                    extinfLine += ` tvg-logo="${entry.logoUrl}"`;
                }
                extinfLine += ` group-title="${entry.category}",${entry.name}`;
                // [ЛОГО: КОНЕЦ ИЗМЕНЕНИЯ]

                // Добавляем EXTINF
                if (entry.extinf) {
                    // [ЛОГО: ИЗМЕНЕНИЕ] Используем пересобранную строку
                    modifiedLines.push(extinfLine);
                    // [ЛОГО: КОНЕЦ ИЗМЕНЕНИЯ]
                }
                // Для TXT добавляем EXTGRP (если он был в оригинале и не был добавлен выше)
                if (format === 'txt' && entry.extgrp && cat === 'Без категории') {
                    // Если у канала есть extgrp, но он в 'Без категории', мы его добавляем.
                    modifiedLines.push(entry.extgrp);
                }
                
                // Добавляем URL
                modifiedLines.push(entry.url);
            });
            
            // Добавляем пустую строку после категории (только если это не самый конец)
            // (Простой способ избежать двойной пустой строки в конце)
             if (format !== 'txt' || cat !== sortedCategories[sortedCategories.length - 1]) {
                 modifiedLines.push('');
             }
        });
        
        // Удаляем последнюю пустую строку, если она есть
        if (modifiedLines.length > 0 && modifiedLines[modifiedLines.length - 1] === '') {
            modifiedLines.pop();
        }
        
        return modifiedLines.join('\n');
    }


    // =======================================================
    // ОБНОВЛЕННЫЙ ОБРАБОТЧИК КНОПКИ СОХРАНИТЬ (АСИНХРОННЫЙ)
    // =======================================================
    saveBtn.addEventListener('click', async () => {
      
      // 1. Формирование контента для сервера (всегда M3U8)
      const contentForServer = generatePlaylistContent('m3u8');
      editedContent = contentForServer;
      
      // Определяем количество каналов
      const finalChannelCount = channels.filter(c => !excludedCategories.has(c.category)).length; 

      // 2. УПРАВЛЕНИЕ ДЛЯ ГОСТЯ
      if (isAnonymousUser) {
          finalFileName.textContent = `ФАЙЛ ${finalChannelCount} КАНАЛОВ`;
          // Скрываем контейнер динамической ссылки и выбор формата
          document.getElementById('dynamicLinkContainer').classList.add('hidden');
          formatSelectContainer.classList.add('hidden');
          
          saveModal.classList.remove('hidden');
          return;
      }
      
      // 3. ЛОГИКА ДЛЯ АВТОРИЗОВАННОГО ПОЛЬЗОВАТЕЛЯ 
      const persistentUserId = userId; 
      const longDynamicLink = `https://read24.netlify.app/api/playlist/${persistentUserId}/latest.m3u`;
      
      // Показываем элементы для авторизованного пользователя
      document.getElementById('dynamicLinkContainer').classList.remove('hidden');
      formatSelectContainer.classList.remove('hidden');
      guestFormatMessage.classList.add('hidden');
      
      finalFileName.textContent = `ФАЙЛ ${finalChannelCount} КАНАЛОВ`;
      dynamicPlaylistLink.value = "Сокращаю ссылку...";
      shortLinkLoader.classList.remove('hidden');
      document.getElementById('formatSelect').value = 'm3u'; // Сброс формата
      saveModal.classList.remove('hidden');
      
      // Асинхронно сокращаем ссылку
      const shortLink = await shortenDynamicLink(longDynamicLink);
      
      // 4. Обновляем UI и запускаем сохранение на сервере
      shortLinkLoader.classList.add('hidden');
      dynamicPlaylistLink.value = shortLink;
      
      // Запускаем сохранение на GitHub в фоне (включает ожидание)
      uploadPlaylistToGitHub(contentForServer, finalChannelCount, persistentUserId); 
    });

    // =======================================================
    // ОБНОВЛЕННЫЙ ОБРАБОТЧИК ЛОКАЛЬНОГО СКАЧИВАНИЯ
    // =======================================================
    downloadBtn.addEventListener('click', () => {
        
      // Гость скачивает только в M3U, авторизованный выбирает
      const selectedFormat = isAnonymousUser ? 'm3u' : formatSelect.value;
      const contentToDownload = generatePlaylistContent(selectedFormat);

      // Определение MIME-типа и расширения файла
      let mimeType = 'text/plain;charset=utf-8';
      let fileExtension = selectedFormat;
      if (selectedFormat === 'm3u') {
          mimeType = 'application/x-mpegurl;charset=utf-8';
      } else if (selectedFormat === 'm3u8') {
          mimeType = 'application/x-mpegurl;charset=utf-8';
      } else if (selectedFormat === 'txt') {
          mimeType = 'text/plain;charset=utf-8';
      }


      const blob = new Blob([contentToDownload], { type: mimeType });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      
      // Считаем каналы для имени файла
      const remainingChannels = channels.filter(entry => {
        const isNormalCategoryExcluded = excludedCategories.has(entry.category);
        const isFavoriteCategoryExcluded = excludedCategories.has(FAVORITE_CATEGORY);
        const isFavorite = entry.isFavorite;

        if (isFavorite) {
            return !isFavoriteCategoryExcluded;
        }
        
        return !isNormalCategoryExcluded;
      });
      
      const remainingCount = remainingChannels.length; 
      // Имя файла для локального скачивания
      a.download = `playlist_${remainingCount}.${fileExtension}`; 
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    });

    closeSaveModal.addEventListener('click', () => {
      saveModal.classList.add('hidden');
      // При закрытии модалки восстанавливаем видимость динамической ссылки для авторизованных
      if (!isAnonymousUser) {
           document.getElementById('dynamicLinkContainer').classList.remove('hidden');
      }
    });
    
  </script>
</body>
</html>