<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Редактировать Плейлист</title>
  <link rel="icon" type="image/x-icon" href="https://read24.netlify.app/icon1.ico">
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdn.jsdelivr.net/npm/sortablejs@1.15.0/Sortable.min.js"></script>
  <style>
    /* Добавляем стили для прокрутки категорий */
    #categoryFilter {
      max-height: 200px;
      overflow-y: auto;
      border: 1px solid #e5e7eb;
      border-radius: 0.75rem; /* rounded-xl */
      padding: 0.5rem; /* p-2 */
    }
    @keyframes fade-in {
      from { opacity: 0; transform: translateY(10px); }
      to { opacity: 1; transform: translateY(0); }
    }
    .animate-fade-in {
      animation: fade-in 0.3s ease-out;
    }
    /* CSS ДЛЯ АНИМАЦИИ ДИНАМИЧЕСКОГО ТЕКСТА */
    @keyframes text-fade-in {
      from { opacity: 0; transform: translateY(5px); }
      to { opacity: 1; transform: translateY(0); }
    }
    .dynamic-text-animated {
      animation: text-fade-in 0.4s ease-out;
    }
    /* КОНЕЦ НОВОГО CSS */

    /* НОВЫЕ СТИЛЫ ДЛЯ БЛОКА "КАК ЭТО РАБОТАЕТ" */
    @keyframes step-fade-in {
        from { opacity: 0; transform: translateY(20px); }
        to { opacity: 1; transform: translateY(0); }
    }
    .step-item {
        animation: step-fade-in 0.6s ease-out forwards;
        opacity: 0; /* Скрываем по умолчанию */
    }
    .step-item:nth-child(1) { animation-delay: 0s; }
    .step-item:nth-child(2) { animation-delay: 0.15s; }
    .step-item:nth-child(3) { animation-delay: 0.30s; }
    .step-item:nth-child(4) { animation-delay: 0.45s; }
    
    /* Стили для элемента, который можно перетаскивать */
    .sortable-channel {
      cursor: grab;
      touch-action: none; /* Улучшает работу на мобильных */
    }
    
    /* Стили для обратной связи при перетаскивании */
    .sortable-ghost {
      opacity: 0.4;
      background-color: #f3f4f6; /* bg-gray-100 */
      border: 2px dashed #9ca3af; /* border-gray-400 */
      border-radius: 0.75rem;
    }

    /* Добавляем отступ к body, чтобы контент не перекрывался фиксированной шапкой */
    body {
        padding-top: 60px; /* Высота шапки + небольшой запас */
    }
    
    /* ************************************************************ */
    /* МОБИЛЬНАЯ АДАПТАЦИЯ: 24PX ДЛЯ ОСНОВНОГО ЗАГОЛОВКА */
    /* ************************************************************ */
    @media (max-width: 640px) { /* sm breakpoint по умолчанию в Tailwind */
        #heroBlock h1 {
            font-size: 24px; /* Устанавливаем 24px */
        }
        
      .channel-item {
        flex-direction: column;
        align-items: flex-start;
        padding: 0.75rem 1rem; /* Увеличим отступы */
      }
      .channel-name {
        max-width: 100% !important; /* На всю ширину */
        margin-bottom: 0.5rem;
        font-size: 20px; /* ИЗМЕНЕНО: Размер 20px */
        font-weight: 900; /* Максимально жирный шрифт */
      }
      /* ИЗМЕНЕНИЕ: На мобильном режиме название и нумерация должны быть в одной линии */
      .channel-item-content {
          width: 100%; /* Занимает всю ширину */
          justify-content: flex-start;
      }
      .channel-buttons-container {
        display: flex; /* Снова делаем flex для кнопок */
        flex-direction: row; /* Горизонтальное расположение кнопок */
        justify-content: space-between;
        width: 100%; /* Занимает всю ширину */
      }
      
      .channel-download-btn, .channel-delete-btn, .channel-favorite-btn { /* ДОБАВЛЕН .channel-favorite-btn */
          flex-shrink: 0;
      }
      
      /* НОВЫЕ СТИЛЫ ДЛЯ МОБИЛЬНОЙ АДАПТАЦИИ ЭКРАНА РЕДАКТОРА */
      #editorScreen .sm\\:justify-between {
          justify-content: center; /* Центрируем заголовок на мобильных */
      }
      #editorScreen .sm\\:items-center {
          align-items: center; 
      }
      #editorScreen .sm\\:flex-row {
          flex-direction: column; /* Размещаем заголовок и кнопки вертикально */
      }
      #editorScreen .sm\\:text-left {
          text-align: center; /* Центрируем заголовок */
      }
      #editorScreen .sm\\:w-auto {
          width: 100%; /* Кнопки на всю ширину */
          justify-content: center;
          margin-top: 0.5rem; /* Отступ сверху для кнопок */
      }

      /* Стили для мобильного меню (Гамбургер) */
      #siteMenu {
          position: absolute;
          top: 56px; /* Высота шапки */
          left: 0;
          right: 0;
          background-color: white;
          padding: 1rem 0;
          box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -2px rgba(0, 0, 0, 0.1);
          flex-direction: column;
          align-items: center;
          z-index: 20;
          display: none;
      }
      #siteMenu.open {
          display: flex;
      }
      #siteMenu a {
          padding: 0.5rem 1rem;
          width: 100%;
          text-align: center;
          border-bottom: 1px solid #f3f4f6; /* gray-100 */
      }
    }
    /* Стили для настольной версии */
    @media (min-width: 641px) {
        #menuButton {
            display: none; /* Скрываем гамбургер на десктопе */
        }
        /* Главный контейнер шапки теперь использует flex-basis/grow для центрирования меню */
        .header-content {
            display: flex;
            width: 100%;
            justify-content: space-between;
            align-items: center;
        }
        /* Центрирование меню между лого и кнопками */
        #siteMenu {
            display: flex;
            flex-grow: 1; /* Позволяем меню занять доступное пространство */
            justify-content: center; /* Центрируем содержимое меню */
            align-items: center;
        }
        /* Для выравнивания логотипа и кнопок вправо */
        .auth-container {
            flex-shrink: 0;
            display: flex;
            align-items: center;
        }
    }
    
    /* Стили для карточек сравнения */
    .comparison-card {
        /* Обновленные стили: более выраженная тень */
        flex-direction: column;
        width: 100%;
        margin-left: auto;
        margin-right: auto;
        padding: 1.5rem;
        background-color: #ffffff; /* bg-white */
        border-radius: 1rem; /* rounded-2xl */
        border-top-width: 4px;
        box-shadow: 0 10px 20px -5px rgba(0, 0, 0, 0.15), 0 4px 6px -2px rgba(0, 0, 0, 0.05); /* Усиленная тень */
        transition: transform 0.3s ease-out; /* Плавное движение при наведении */
    }
    .comparison-feature {
        /* Изменено: Используем flex-start для выравнивания текста влево */
        display: flex;
        align-items: flex-start;
        justify-content: space-between;
        color: #374151; /* text-gray-700 */
        padding-top: 0.75rem;
        padding-bottom: 0.75rem;
        border-bottom: 1px solid #f3f4f6; /* border-gray-100 */
        text-align: left; /* Текст слева */
    }
    .comparison-feature span:first-child {
        /* Текст преимущества - занимает основное место, позволяет перенос */
        text-align: left;
        max-width: 85%; /* Оставляем место для иконки справа */
        line-height: 1.5;
    }
    .comparison-feature span:last-child {
        /* Иконка - строго справа */
        flex-shrink: 0;
        margin-left: 0.5rem;
    }

    /* Анимация появления для всего блока сравнения (для примера) */
    @keyframes card-slide-in {
        from { opacity: 0; transform: translateY(30px); }
        to { opacity: 1; transform: translateY(0); }
    }
    #comparisonBlock .comparison-card:first-child {
        animation: card-slide-in 0.6s ease-out forwards;
    }
    #comparisonBlock .comparison-card:last-child {
        animation: card-slide-in 0.6s ease-out 0.2s forwards; /* Задержка для второй карточки */
    }
    
    /* Стили для FAQ (Аккордеон) */
    .faq-item {
        border-bottom: 1px solid #e5e7eb;
        cursor: pointer;
    }
    .faq-question {
        font-weight: 600;
        color: #1f2937;
        padding: 1rem 0;
        display: flex;
        justify-content: space-between;
        align-items: center;
        transition: color 0.2s ease-in-out; /* Анимация цвета */
        
        /* Добавление иконки "вниз" по умолчанию */
        background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='16' height='16' viewBox='0 0 24 24' fill='none' stroke='%234b5563' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpolyline points='6 9 12 15 18 9'%3E%3C/polyline%3E%3C/svg%3E");
        background-repeat: no-repeat;
        background-position: right center;
        padding-right: 2rem; /* Отступ для иконки */
    }
    .faq-question:hover {
        color: #ef4444; /* red-500 */
    }

    /* Активное состояние вопроса: текст красный и иконка "вверх" */
    .faq-item[aria-expanded="true"] .faq-question {
        color: #ef4444; /* red-500 */
        background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='16' height='16' viewBox='0 0 24 24' fill='none' stroke='%23ef4444' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpolyline points='18 15 12 9 6 15'%3E%3C/polyline%3E%3C/svg%3E");
    }

    .faq-answer {
        padding-bottom: 0rem;
        padding-top: 0rem;
        color: #4b5563;
        max-height: 0;
        overflow: hidden;
        transition: max-height 0.3s ease-out, padding 0.3s ease-out;
    }
    .faq-item[aria-expanded="true"] .faq-answer {
        max-height: 300px; /* Достаточно для плавного открытия */
        padding-bottom: 1rem;
    }
    
    /* Стили для Базы знаний */
    .article-card {
        transition: transform 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
    }
    .article-card:hover {
        transform: translateY(-5px);
        box-shadow: 0 15px 25px -5px rgba(239, 68, 68, 0.15); /* red-500 shadow */
    }
    
    /* Стили для картинок в сравнении */
    .comparison-icon {
        width: 1.5rem; /* h-6 */
        height: 1.5rem; /* w-6 */
        object-fit: contain;
    }

    /* СТИЛЫ ДЛЯ КВАДРАТНОГО МОДАЛЬНОГО ОКНА РЕГИСТРАЦИИ */
    .square-modal-content {
        aspect-ratio: 1 / 1; /* Делаем окно квадратным */
        max-width: 400px;
        width: 90%;
        padding: 1.5rem;
        position: relative; /* Для позиционирования кнопки закрытия */
        display: flex;
        flex-direction: column;
        justify-content: center; /* Центрируем контент */
        align-items: center;
    }
    
    /* СТИЛЫ ДЛЯ ЛОГОТИПА */
    .logo-link img {
        transition: transform 0.2s ease-in-out;
    }
    .logo-link:hover img {
        transform: scale(1.2); /* Увеличение на 20% при наведении */
    }
    /* Стили для нумерации в списке */
    .channel-number {
        font-weight: 700;
        color: #ef4444; /* red-500 */
        margin-right: 0.75rem;
        width: 20px; /* Фиксированная ширина */
        text-align: right;
    }
    .channel-item-content {
        display: flex;
        align-items: center;
        flex-grow: 1;
        min-width: 0; /* Обеспечивает корректное сжатие Flex-элемента */
    }
    /* ИЗМЕНЕНИЕ: Стили для сокращения названия канала многоточием */
    .channel-name {
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
        min-width: 50px; /* Минимальная ширина, чтобы текст не исчезал */
    }

  </style>
</head>
<body class="bg-white text-black min-h-screen flex items-center justify-center px-4">

  <header id="siteHeader" class="fixed top-0 left-0 w-full bg-white shadow-md z-30">
    <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 h-14 flex justify-between items-center header-content">
      
      <a href="/" class="flex items-center space-x-2 flex-shrink-0 logo-link">
        <img src="https://read24.netlify.app/icon1.ico" alt="Логотип" class="h-8 w-8">
        <span class="text-xl font-bold text-gray-800 hidden sm:inline"></span>
      </a>

      <nav id="siteMenu" class="hidden sm:flex space-x-6">
        <a href="#whyUsBlock" class="menu-link text-gray-600 hover:text-red-600 transition">Преимущества</a>
        <a href="#howItWorksBlock" class="menu-link text-gray-600 hover:text-red-600 transition">Как редактировать</a>
        <a href="#comparisonBlock" class="menu-link text-gray-600 hover:text-red-600 transition">Сравнение</a>
        <a href="#faqBlock" class="menu-link text-gray-600 hover:text-red-600 transition">Частые вопросы</a>
        <a href="/free-playlists" id="freePlaylistsLink" class="menu-link text-gray-600 hover:text-red-600 transition">Полезные программы</a>
        <a href="#knowledgeBaseBlock" id="knowledgeBaseLink" class="menu-link text-gray-600 hover:text-red-600 transition">База знаний</a>
        </nav>

      <div class="flex items-center space-x-4 auth-container flex-shrink-0">
        
        <button id="openRegisterModalBtnHeader" 
            class="bg-black text-white text-sm font-semibold px-4 py-2 rounded-xl shadow-md hover:bg-gray-900 transition">
            ВОЙТИ / РЕГИСТРАЦИЯ
        </button>

        <button id="logoutBtn"
          class="bg-red-600 text-white text-sm font-semibold px-4 py-2 rounded-xl shadow-md hover:bg-red-700 transition hidden">
          ВЫЙТИ
        </button>

        <button id="menuButton" class="sm:hidden text-gray-600 hover:text-red-600 transition p-2">
            <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16m-7 6h7"></path>
            </svg>
        </button>
      </div>
    </div>
  </header>
  
  <div id="mainScreen" class="text-center w-full max-w-6xl"> 
    
    <div id="heroBlock" class="animate-fade-in mb-8 w-full max-w-4xl mx-auto flex flex-col items-center justify-center min-h-[calc(100vh-60px)]"> 
        <h1 class="text-3xl sm:text-5xl font-extrabold text-gray-800 leading-tight mb-4 max-w-4xl mx-auto">
            <span class="block">Редактируйте любые плейлисты</span>
            <span class="block">
                <span id="staticTitlePart" class="text-gray-800">для </span>
                <span id="dynamicTitlePart" class="text-red-600">полного контроля</span><span class="text-red-600">.</span>
            </span>
        </h1>
        <p class="text-base sm:text-lg text-gray-600 mb-6 max-w-2xl mx-auto">
            Получите полный контроль над вашими медиатеками, объединяя
            источники и настраивая порядок просмотра.
        </p>
        <button id="goToWhyUsBtn"
            class="bg-red-600 text-white text-lg font-semibold px-10 py-3 rounded-2xl shadow-xl hover:bg-red-700 transition transform hover:scale-105">
            Начать редактирование
        </button>
    </div>
    
    <div id="whyUsBlock" class="w-full max-w-7xl mx-auto py-10 px-4 sm:px-6 lg:px-8 flex flex-col items-center justify-center min-h-[calc(100vh-60px)]">
        <span class="text-red-600 font-bold text-sm uppercase tracking-wider block mb-2">ПОЧЕМУ МЫ?</span>
        <h2 class="text-2xl sm:text-4xl font-extrabold text-gray-800 mb-10">
            Возможности для ваших плейлистов
        </h2>

        <div class="flex flex-wrap justify-center gap-6">
            
            <div class="w-full sm:w-80 p-6 bg-white rounded-2xl shadow-xl flex flex-col items-center text-center transition hover:shadow-2xl">
                <div class="text-red-600 text-4xl mb-4">
                    <img src="https://read24.netlify.app/image/approved.png" alt="Полный контроль" class="w-10 h-10 mx-auto" />
                </div>
                <h3 class="text-xl font-bold text-gray-800 mb-3">Полный контроль</h3>
                <p class="text-gray-600 text-sm">
                    Настраивайте порядок воспроизведения, удаляйте ненужное и добавляйте новый контент в вашу библиотеку за секунды.
                </p>
            </div>

            <div class="w-full sm:w-80 p-6 bg-white rounded-2xl shadow-xl flex flex-col items-center text-center transition hover:shadow-2xl">
                <div class="text-red-600 text-4xl mb-4">
                    <img src="https://read24.netlify.app/image/views.png" alt="Просмотр без границ" class="w-10 h-10 mx-auto" />
                </div>
                <h3 class="text-xl font-bold text-gray-800 mb-3">Просмотр без границ</h3>
                <p class="text-gray-600 text-sm">
                    Смотрите ваши плейлисты на любом устройстве: от мобильного телефона до Smart TV. Всегда синхронизировано.
                </p>
            </div>

            <div class="w-full sm:w-80 p-6 bg-white rounded-2xl shadow-xl flex flex-col items-center text-center transition hover:shadow-2xl">
                <div class="text-red-600 text-4xl mb-4">
                    <img src="https://read24.netlify.app/image/library.png" alt="Единая библиотека" class="w-10 h-10 mx-auto" />
                </div>
                <h3 class="text-xl font-bold text-gray-800 mb-3">Единая библиотека</h3>
                <p class="text-gray-600 text-sm">
                    Объединяйте медиафайлы из разных источников в одно централизованное и удобное место для доступа.
                </p>
            </div>
        </div>
        
        <button id="startEditingBtn"
            class="bg-red-600 text-white text-lg font-semibold px-10 py-3 rounded-2xl shadow-xl hover:bg-red-700 transition transform hover:scale-105 mt-10">
            Начать редактирование
        </button>
    </div>

    <div id="howItWorksBlock" class="w-full max-w-7xl mx-auto py-10 px-4 sm:px-6 lg:px-8 flex flex-col items-center justify-center min-h-[calc(100vh-60px)]">
        <span class="text-red-600 font-bold text-sm uppercase tracking-wider block mb-2">КАК ЭТО РАБОТАЕТ</span>
        <h2 class="text-2xl sm:text-4xl font-extrabold text-gray-800 mb-12">
            Процесс Редактирования: Начните за 4 Шага
        </h2>

        <div class="grid grid-cols-1 md:grid-cols-4 gap-8 max-w-6xl mx-auto relative">
            
            <div class="hidden md:block absolute top-1/4 bottom-1/4 left-0 right-0 h-1 bg-gray-200 mx-10"></div>

            <div class="step-item flex flex-col items-center text-center relative z-10">
                <div class="w-20 h-20 bg-red-600 text-white font-black rounded-full flex items-center justify-center text-3xl mb-4 ring-4 ring-red-200">1</div>
                <h3 class="text-xl font-extrabold text-gray-800 mb-2">Регистрация</h3>
                <p class="text-gray-600 text-sm">
                    Быстро создайте личный кабинет, чтобы получить доступ ко всем инструментам редактирования и облачному хранилищу.
                </p>
                <div class="md:hidden h-10 w-1 bg-gray-200 mt-4"></div>
            </div>

            <div class="step-item flex flex-col items-center text-center relative z-10">
                <div class="w-20 h-20 bg-red-600 text-white font-black rounded-full flex items-center justify-center text-3xl mb-4 ring-4 ring-red-200">2</div>
                <h3 class="text-xl font-extrabold text-gray-800 mb-2">Загрузите плейлист</h3>
                <p class="text-gray-600 text-sm">
                    Импортируйте файл .m3u, .m3u8, или другой поддерживаемый формат, используя прямую ссылку или загрузку с устройства.
                </p>
                <div class="md:hidden h-10 w-1 bg-gray-200 mt-4"></div>
            </div>

            <div class="step-item flex flex-col items-center text-center relative z-10">
                <div class="w-20 h-20 bg-red-600 text-white font-black rounded-full flex items-center justify-center text-3xl mb-4 ring-4 ring-red-200">3</div>
                <h3 class="text-xl font-extrabold text-gray-800 mb-2">Отредактируйте список</h3>
                <p class="text-gray-600 text-sm">
                    Используйте удобный drag-and-drop интерфейс для изменения порядка, удаления или добавления новых каналов/ссылок.
                </p>
                <div class="md:hidden h-10 w-1 bg-gray-200 mt-4"></div>
            </div>

            <div class="step-item flex flex-col items-center text-center relative z-10">
                <div class="w-20 h-20 bg-red-600 text-white font-black rounded-full flex items-center justify-center text-3xl mb-4 ring-4 ring-red-200">4</div>
                <h3 class="text-xl font-extrabold text-gray-800 mb-2">Сохраните и используйте</h3>
                <p class="text-gray-600 text-sm">
                    Сохраните изменения. Вы получите новую ссылку, которая будет автоматически обновляться, или скачаете готовый файл.
                </p>
                </div>
        </div>
    </div>
    
    <div id="comparisonBlock" class="w-full max-w-7xl mx-auto py-10 px-4 sm:px-6 lg:px-8 flex flex-col items-center justify-center min-h-[calc(100vh-60px)] bg-white">
        <span class="text-red-600 font-bold text-sm uppercase tracking-wider block mb-2">ВЫБЕРИТЕ СВОЙ ПУТЬ</span>
        <h2 class="text-2xl sm:text-4xl font-extrabold text-gray-800 mb-10">
            Сравнение Доступов: С регистрацией vs Без нее
        </h2>

        <div class="flex flex-col lg:flex-row gap-8 w-full max-w-4xl">
            
            <div class="comparison-card border-gray-400">
                <h3 class="text-2xl font-bold text-gray-800 mb-2 text-left">Без регистрации</h3>
                <p class="text-sm text-gray-500 mb-6 text-left">Базовые возможности для быстрого редактирования.</p>

                <div class="flex-grow">
                    <div class="comparison-feature">
                        <span>Единоразовое редактирование плейлиста</span>
                        <span><img src="https://read24.netlify.app/image/1.png" alt="Доступно" class="comparison-icon" /></span>
                    </div>
                    <div class="comparison-feature">
                        <span>Сохранение плейлиста в облаке</span>
                        <span><img src="https://read24.netlify.app/image/2.png" alt="Недоступно" class="comparison-icon" /></span>
                    </div>
                    <div class="comparison-feature">
                        <span>Динамическая ссылка на плейлист (автообновление)</span>
                        <span><img src="https://read24.netlify.app/image/2.png" alt="Недоступно" class="comparison-icon" /></span>
                    </div>
                    <div class="comparison-feature">
                        <span>Доступ к истории изменений</span>
                        <span><img src="https://read24.netlify.app/image/2.png" alt="Недоступно" class="comparison-icon" /></span>
                    </div>
                    <div class="comparison-feature border-none">
                        <span>Синхронизация между устройствами</span>
                        <span><img src="https://read24.netlify.app/image/2.png" alt="Недоступно" class="comparison-icon" /></span>
                    </div>
                </div>

                <button class="w-full bg-gray-300 text-gray-800 text-lg font-semibold px-4 py-3 rounded-xl shadow-lg mt-6 hover:bg-gray-400 transition" id="startNoRegBtn">
                    Начать редактирование
                </button>
            </div>

            <div class="comparison-card border-red-600">
                <h3 class="text-2xl font-bold text-red-600 mb-2 text-left">С регистрацией</h3>
                <p class="text-sm text-gray-500 mb-6 text-left">Полный доступ ко всем функциям и облаку.</p>

                <div class="flex-grow">
                    <div class="comparison-feature">
                        <span>Единоразовое редактирование плейлиста</span>
                        <span><img src="https://read24.netlify.app/image/1.png" alt="Доступно" class="comparison-icon" /></span>
                    </div>
                    <div class="comparison-feature">
                        <span>Сохранение плейлиста в облаке</span>
                        <span><img src="https://read24.netlify.app/image/1.png" alt="Доступно" class="comparison-icon" /></span>
                    </div>
                    <div class="comparison-feature">
                        <span>Динамическая ссылка на плейлист (автообновление)</span>
                        <span><img src="https://read24.netlify.app/image/1.png" alt="Доступно" class="comparison-icon" /></span>
                    </div>
                    <div class="comparison-feature">
                        <span>Доступ к истории изменений</span>
                        <span><img src="https://read24.netlify.app/image/1.png" alt="Доступно" class="comparison-icon" /></span>
                    </div>
                    <div class="comparison-feature border-none">
                        <span>Синхронизация между устройствами</span>
                        <span><img src="https://read24.netlify.app/image/1.png" alt="Доступно" class="comparison-icon" /></span>
                    </div>
                </div>

                <button id="registerNowCardBtn" class="w-full bg-red-600 text-white text-lg font-semibold px-4 py-3 rounded-xl shadow-lg mt-6 hover:bg-red-700 transition transform hover:scale-105">
                    Регистрация
                </button>
            </div>
        </div>

        <p class="text-gray-600 text-sm mt-10 max-w-xl">
            Для получения максимального удобства и доступа ко всем продвинутым функциям редактирования плейлистов, рекомендуем пройти **"быструю регистрацию"**.
        </p>
    </div>
    
    <div id="faqBlock" class="w-full max-w-7xl mx-auto py-10 px-4 sm:px-6 lg:px-8 flex flex-col items-center justify-center min-h-[calc(100vh-60px)]">
        <span class="text-red-600 font-bold text-sm uppercase tracking-wider block mb-2">СПРОСИТЕ НАС</span>
        <h2 class="text-2xl sm:text-4xl font-extrabold text-gray-800 mb-10">
            Частые вопросы
        </h2>

        <div class="w-full max-w-2xl text-left border-t border-gray-200">
            
            <div class="faq-item" tabindex="0" aria-expanded="false">
                <div class="faq-question" onclick="toggleFaq(this.parentElement)">
                    Какие форматы плейлистов поддерживает ваш редактор?
                </div>
                <div class="faq-answer">
                    <p>
                        Импортируйте файлы в форматах **.m3u**, **.m3u8**, или **других поддерживаемых форматах**, используя прямую ссылку или загрузку с устройства.
                    </p>
                </div>
            </div>

            <div class="faq-item" tabindex="0" aria-expanded="false">
                <div class="faq-question" onclick="toggleFaq(this.parentElement)">
                    Могу ли я объединить несколько плейлистов в один?
                </div>
                <div class="faq-answer">
                    <p>
                        Да, это одна из ключевых возможностей нашего сервиса! Вы можете легко импортировать несколько файлов или ссылок, а затем объединить их в одну централизованную библиотеку.
                    </p>
                </div>
            </div>

            <div class="faq-item" tabindex="0" aria-expanded="false">
                <div class="faq-question" onclick="toggleFaq(this.parentElement)">
                    Что такое "Динамическая ссылка на плейлист" и как она работает?
                </div>
                <div class="faq-answer">
                    <p>
                        Динамическая ссылка (доступна после регистрации) — это постоянный URL вашего плейлиста. Когда вы вносите изменения в список через наш редактор, плейлист по этой ссылке **"автоматически обновляется"** на всех ваших устройствах (Smart TV, плееры и т.д.).
                    </p>
                </div>
            </div>

            <div class="faq-item" tabindex="0" aria-expanded="false">
                <div class="faq-question" onclick="toggleFaq(this.parentElement)">
                    Безопасно ли загружать мой плейлист?
                </div>
                <div class="faq-answer">
                    <p>
                        Абсолютно. Мы гарантируем полную конфиденциальность и не храним личные данные или содержимое ваших плейлистов, если вы сами не решите сохранить их в личном кабинете. Даже в этом случае они защищены.
                    </p>
                </div>
            </div>

            <div class="faq-item" tabindex="0" aria-expanded="false">
                <div class="faq-question" onclick="toggleFaq(this.parentElement)">
                    Могу ли я изменить порядок каналов/ссылок?
                </div>
                <div class="faq-answer">
                    <p>
                        Да. Наш редактор имеет интуитивно понятный интерфейс **"Drag-and-Drop (перетаскивание)"**, который позволяет легко менять порядок элементов в списке простым движением мыши или касанием.
                    </p>
                </div>
            </div>
            
            <div class="faq-item" tabindex="0" aria-expanded="false">
                <div class="faq-question" onclick="toggleFaq(this.parentElement)">
                    Нужно ли регистрироваться, чтобы отредактировать один плейлист?
                </div>
                <div class="faq-answer">
                    <p>
                        Нет, для **"единоразового редактирования"** и скачивания файла регистрация не требуется. Однако, чтобы сохранить плейлисты в облаке и получить динамическую ссылку для автообновления, регистрация необходима.
                    </p>
                </div>
            </div>
            
            <div class="faq-item" tabindex="0" aria-expanded="false">
                <div class="faq-question" onclick="toggleFaq(this.parentElement)">
                    Работает ли ваш редактор на мобильных устройствах?
                </div>
                <div class="faq-answer">
                    <p>
                        Да, наш сервис полностью адаптирован и корректно работает на всех современных устройствах, включая смартфоны, планшеты и настольные компьютеры.
                    </p>
                </div>
            </div>
        </div>
    </div>
    
    <div id="knowledgeBaseBlock" class="w-full max-w-7xl mx-auto py-10 px-4 sm:px-6 lg:px-8 flex flex-col items-center min-h-[calc(100vh-60px)]">
        <span class="text-red-600 font-bold text-sm uppercase tracking-wider block mb-2">ПОЛЕЗНАЯ ИНФОРМАЦИЯ</span>
        <h2 class="text-2xl sm:text-4xl font-extrabold text-gray-800 mb-10">
            База знаний IPTV и Плейлистов
        </h2>
        
        <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6 w-full max-w-6xl text-left">
            
            <a href="#" class="article-card block bg-white p-6 rounded-xl shadow-lg border border-gray-100">
                <h3 class="text-xl font-bold text-gray-800 mb-2 hover:text-red-600 transition">Что такое IPTV и как оно работает?</h3>
                <p class="text-gray-600 text-sm">Подробное объяснение технологии Internet Protocol Television, ее преимуществ перед кабельным ТВ и принципов работы.</p>
                <span class="text-xs text-red-500 font-semibold mt-3 block">#IPTV_База</span>
            </a>

            <a href="#" class="article-card block bg-white p-6 rounded-xl shadow-lg border border-gray-100">
                <h3 class="text-xl font-bold text-gray-800 mb-2 hover:text-red-600 transition">Форматы плейлистов M3U и M3U8: различия и использование.</h3>
                <p class="text-gray-600 text-sm">Разбор двух наиболее популярных форматов плейлистов, включая их структуру и расширения, такие как #EXTINF.</p>
                <span class="text-xs text-red-500 font-semibold mt-3 block">#M3U_Гайд</span>
            </a>

            <a href="#" class="article-card block bg-white p-6 rounded-xl shadow-lg border border-gray-100">
                <h3 class="text-xl font-bold text-gray-800 mb-2 hover:text-red-600 transition">Как выбрать лучший IPTV-плеер для вашего устройства.</h3>
                <p class="text-gray-600 text-sm">Обзор и сравнение популярных приложений для Smart TV, Android, iOS и ПК, поддерживающих плейлисты M3U.</p>
                <span class="text-xs text-red-500 font-semibold mt-3 block">#Плееры_Обзор</span>
            </a>

            <a href="#" class="article-card block bg-white p-6 rounded-xl shadow-lg border border-gray-100">
                <h3 class="text-xl font-bold text-gray-800 mb-2 hover:text-red-600 transition">Решение проблем: почему плейлист не загружается или каналы не работают.</h3>
                <p class="text-gray-600 text-sm">Пошаговое руководство по диагностике и исправлению распространенных ошибок, связанных с нерабочими ссылками и блокировками.</p>
                <span class="text-xs text-red-500 font-semibold mt-3 block">#Troubleshooting</span>
            </a>

            <a href="#" class="article-card block bg-white p-6 rounded-xl shadow-lg border border-gray-100">
                <h3 class="text-xl font-bold text-gray-800 mb-2 hover:text-red-600 transition">Структура IPTV плейлиста: #EXTINF и атрибуты group-title.</h3>
                <p class="text-gray-600 text-sm">Углубленное изучение обязательных и необязательных тегов в плейлисте, влияющих на сортировку и отображение категорий.</p>
                <span class="text-xs text-red-500 font-semibold mt-3 block">#EXTINF_Секреты</span>
            </a>

            <a href="#" class="article-card block bg-white p-6 rounded-xl shadow-lg border border-gray-100">
                <h3 class="text-xl font-bold text-gray-800 mb-2 hover:text-red-600 transition">Как объединить плейлисты из разных источников в один.</h3>
                <p class="text-gray-600 text-sm">Практический гайд по консолидации нескольких M3U файлов для создания единой, упорядоченной медиатеки.</p>
                <span class="text-xs text-red-500 font-semibold mt-3 block">#Слияние_Гайд</span>
            </a>
            
            <a href="#" class="article-card block bg-white p-6 rounded-xl shadow-lg border border-gray-100">
                <h3 class="text-xl font-bold text-gray-800 mb-2 hover:text-red-600 transition">Что такое динамическая ссылка на плейлист и почему она удобна.</h3>
                <p class="text-gray-600 text-sm">Объяснение преимущества постоянного URL, который автоматически обновляется при редактировании плейлиста на сервере.</p>
                <span class="text-xs text-red-500 font-semibold mt-3 block">#Динамика</span>
            </a>
            
            <a href="#" class="article-card block bg-white p-6 rounded-xl shadow-lg border border-gray-100">
                <h3 class="text-xl font-bold text-gray-800 mb-2 hover:text-red-600 transition">Синхронизация IPTV на разных устройствах: пошаговая инструкция.</h3>
                <p class="text-gray-600 text-sm">Как обеспечить бесшовный просмотр любимых каналов и настроек на телефоне, планшете и Smart TV.</p>
                <span class="text-xs text-red-500 font-semibold mt-3 block">#Синхронизация</span>
            </a>

            <a href="#" class="article-card block bg-white p-6 rounded-xl shadow-lg border border-gray-100">
                <h3 class="text-xl font-bold text-gray-800 mb-2 hover:text-red-600 transition">Как удалять дубликаты каналов в плейлисте и зачем это нужно.</h3>
                <p class="text-gray-600 text-sm">Советы по очистке плейлиста от повторяющихся ссылок для повышения стабильности и удобства использования.</p>
                <span class="text-xs text-red-500 font-semibold mt-3 block">#Очистка_Дубликатов</span>
            </a>
            
            <a href="#" class="article-card block bg-white p-6 rounded-xl shadow-lg border border-gray-100">
                <h3 class="text-xl font-bold text-gray-800 mb-2 hover:text-red-600 transition">Облачное хранение плейлистов: преимущества и безопасность.</h3>
                <p class="text-gray-600 text-sm">Почему хранить плейлисты онлайн удобнее, чем локально, и как обеспечить безопасность ваших данных.</p>
                <span class="text-xs text-red-500 font-semibold mt-3 block">#Облако_Безопасность</span>
            </a>
            
        </div>
    </div>
    <div id="unauthenticatedMessage" class="hidden"></div>
    <div id="authButtonContainer" class="hidden"></div>

    <input type="file" id="fileInput" accept="*/*" class="hidden">
    
    <div id="loading" class="hidden text-blue-600 mb-4">
      <div class="animate-spin rounded-full h-6 w-6 border-b-2 border-blue-600 mx-auto mb-2"></div>
      Загрузка файла...
    </div>

  </div>

  <div id="editorScreen" class="hidden w-full max-w-7xl mx-auto py-6 px-4">
    <div class="flex flex-col sm:flex-row justify-center sm:justify-between items-center mb-4">
      <h1 class="text-xl font-bold text-gray-800 text-center sm:text-left">РЕДАКТОР КАНАЛОВ</h1>
      <div class="flex gap-2 w-full sm:w-auto justify-center sm:justify-end mt-2 sm:mt-0">
        <button id="openUploadModalBtn"
          class="bg-blue-600 text-white px-5 py-2 rounded-xl hover:bg-blue-700 transition text-sm sm:text-base">
          ЗАГРУЗИТЬ ПЛЕЙЛИСТ
        </button>
        <button id="removeDuplicatesBtn"
          class="bg-red-600 text-white px-5 py-2 rounded-xl hover:bg-red-700 transition text-sm sm:text-base">
          УДАЛИТЬ ДУБЛИ
        </button>
        <button id="saveBtn"
          class="bg-black text-white px-5 py-2 rounded-xl hover:bg-gray-900 transition text-sm sm:text-base">
          СОХРАНИТЬ
        </button>
        <button id="guestLogoutBtn"
          class="bg-gray-600 text-white px-5 py-2 rounded-xl hover:bg-gray-700 transition text-sm sm:text-base hidden">
          ВЫЙТИ
        </button>
        </div>
    </div>
    
    <div class="flex flex-col md:flex-row gap-6">
      
      <div id="filterPanel" class="w-full md:w-2/5 md:max-h-[80vh] md:overflow-y-auto md:p-2">
        <div class="mb-2">
          <input type="text" id="searchInput" placeholder="Поиск канала..."
            class="w-full px-4 py-2 border border-gray-300 rounded-xl focus:outline-none focus:ring-2 focus:ring-black" />
        </div>

        <div class="mb-4">
          <h3 class="text-md font-semibold mb-2 аtext-gray-800">Выбрать категорию для просмотра</h3>
          <select id="categorySelect"
              class="w-full px-4 py-2 border border-gray-300 rounded-xl focus:outline-none focus:ring-2 focus:ring-black bg-white">
              <option value="">Все категории</option>
          </select>
        </div>
        <div class="mb-4">
          <h3 class="text-md font-semibold mb-2 text-gray-800">Исключить категории (отметьте, чтобы удалить)</h3>
          <div id="categoryFilter" class="flex flex-wrap gap-2 p-2 bg-gray-50">
            </div>
        </div>
        
        <div class="text-center mb-4 text-xl font-bold text-red-600">
          КАНАЛОВ В СПИСКЕ: <span id="channelCounter">0</span>
        </div>
      </div>
      
      <div id="listPanel" class="w-full md:w-3/5 md:max-h-[80vh] md:overflow-y-auto md:p-2">
        <div id="channelList" class="space-y-2"></div>
      </div>
    </div>
    
  </div>
  
  <div id="uploadModal"
    class="fixed inset-0 flex items-center justify-center bg-black bg-opacity-50 backdrop-blur-sm hidden z-20">
    <div class="bg-white rounded-3xl p-6 w-[90%] max-w-md shadow-xl animate-fade-in text-center text-black">
      <h2 class="text-xl font-semibold mb-6 text-gray-800">Загрузка нового плейлиста</h2>

      <div id="dropAreaModal" class="p-4 rounded-2xl border-2 border-transparent transition">
          <button id="uploadModalBtn"
            class="bg-black text-white text-lg font-semibold px-6 py-3 rounded-2xl shadow-lg hover:bg-gray-900 transition w-full mx-auto mb-4">
            ЗАГРУЗИТЬ ФАЙЛ
          </button>
          
          <div class="my-4 text-gray-600 hidden">или перетащите сюда</div>
          
          <div class="flex flex-col gap-3 w-full mx-auto mb-4">
            <input type="text" id="urlModalInput" placeholder="Введите ссылку на m3u файл"
              class="w-full px-4 py-3 border border-gray-300 rounded-2xl focus:outline-none focus:ring-2 focus:ring-black bg-gray-50 text-lg shadow-inner">
            
            <button id="loadUrlModalBtn"
              class="w-full bg-black text-white text-lg font-semibold px-6 py-3 rounded-2xl shadow-lg hover:bg-gray-900 transition">
              ВПЕРЕД
            </button>
          </div>
      </div>
      <div id="loadingModal" class="hidden text-blue-600 mt-4">
        <div class="animate-spin rounded-full h-6 w-6 border-b-2 border-blue-600 mx-auto mb-2"></div>
        Загрузка файла...
      </div>

      <button id="closeUploadModal"
        class="w-full bg-gray-200 hover:bg-gray-300 text-gray-900 font-medium py-2 rounded-xl transition mt-4">
        ОТМЕНА
      </button>
    </div>
  </div>

  <div id="registrationModal"
    class="fixed inset-0 flex items-center justify-center bg-black bg-opacity-50 backdrop-blur-sm hidden z-20">
    <div class="bg-white rounded-3xl shadow-xl animate-fade-in text-center text-black square-modal-content">
      
      <button id="closeRegisterModal"
        class="absolute top-4 right-4 text-gray-400 hover:text-gray-600 transition p-1 rounded-full hover:bg-gray-100">
        <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
        </svg>
      </button>

      <h2 class="text-2xl font-extrabold text-center mb-4 text-gray-800">
        Добро пожаловать!
      </h2>
      <p class="text-center text-gray-600 mb-8 text-sm">
        Создайте свой аккаунт, чтобы сохранять плейлисты.
      </p>

      <button id="registerGoogleBtn"
        class="w-full flex items-center justify-center bg-white border border-gray-300 text-gray-700 text-base font-medium px-4 py-3 rounded-xl shadow-sm hover:bg-gray-100 transition mb-3">
        <svg class="w-5 h-5 mr-3" viewBox="0 0 24 24" fill="currentColor">
          <path d="M12.0003 4.75C14.7173 4.75 16.9833 5.772 18.6673 7.359L20.5903 5.487C18.3143 3.498 15.3623 2.25 12.0003 2.25C8.01332 2.25 4.54932 4.53 2.87132 7.824L5.87532 10.125C6.73632 7.787 9.12632 6.25 12.0003 6.25C13.8823 6.25 15.6173 6.942 16.9803 8.167L19.4583 6.135C18.0493 4.904 16.1433 4.25 14.2503 4.25H12.0003V4.75Z" fill="#EA4335"/>
          <path d="M12.0003 17.75C13.2133 17.75 14.3723 17.419 15.3853 16.829L18.3903 19.13C16.6383 20.375 14.3763 21 12.0003 21C7.81732 21 4.28832 18.577 2.50232 15.111L5.53732 12.83C6.34732 15.309 9.07332 17 12.0003 17V17.75Z" fill="#34A853"/>
          <path d="M21.2503 12C21.2503 11.234 21.1813 10.493 21.0543 9.774H12.0003V14.25H17.2273C17.0673 15.186 16.5183 15.996 15.7503 16.591L18.7853 18.868C20.4433 17.375 21.2503 15.342 21.2503 13.007V12Z" fill="#4285F4"/>
          <path d="M5.87532 10.125L2.87132 7.824C2.26132 9.068 2.00032 10.493 2.00032 12C2.00032 13.507 2.26132 14.932 2.87132 16.176L5.87532 13.875V10.125Z" fill="#FBBC05"/>
        </svg>
        Войти через Google
      </button>
      
      </div>
  </div>
  <div id="saveModal"
    class="fixed inset-0 flex items-center justify-center bg-black bg-opacity-50 backdrop-blur-sm hidden z-20">
    <div class="bg-white rounded-3xl p-6 w-[90%] max-w-md shadow-xl animate-fade-in text-center text-black">
      <h2 id="finalFileName" class="text-2xl font-bold mb-6">ФАЙЛ 0 КАНАЛОВ</h2>

      <div id="dynamicLinkContainer" class="mb-6 p-4 bg-gray-100 rounded-xl text-left">
          <h3 class="text-sm font-bold text-gray-800 mb-2">Ваша Короткая Динамическая Ссылка</h3>
          <div id="shortLinkLoader" class="text-center text-blue-600 mb-2 hidden">
              <div class="animate-spin rounded-full h-4 w-4 border-b-2 border-blue-600 mx-auto mb-1"></div>
              Сокращаю...
          </div>
          <input type="text" id="dynamicPlaylistLink" readonly
            class="w-full text-sm font-mono p-2 border border-gray-300 rounded-lg bg-white truncate">
          <button id="copyLinkBtn"
            class="w-full mt-2 bg-blue-600 text-white font-medium py-1 rounded-lg transition hover:bg-blue-700 text-sm">
            КОПИРОВАТЬ ССЫЛКУ
          </button>
      </div>

      <div id="formatSelectContainer" class="mb-4">
        <label for="formatSelect" class="text-sm font-bold text-gray-800 block mb-2 text-left">Формат скачивания:</label>
        <select id="formatSelect"
            class="w-full px-4 py-2 border border-gray-300 rounded-xl focus:outline-none focus:ring-2 focus:ring-black bg-white">
            <option value="m3u">M3U</option>
            <option value="m3u8">M3U8</option>
            <option value="txt">TXT</option>
        </select>
      </div>
      
      <p id="guestFormatMessage" class="mb-4 text-sm font-bold text-gray-800 hidden text-left">
         Формат скачивания для неавторизованных: **M3U**
      </p>

      <button id="downloadBtn"
        class="w-full bg-black text-white font-medium py-2 rounded-xl transition hover:bg-gray-800 mb-2">
        СКАЧАТЬ ЛОКАЛЬНО
      </button>
      <button id="closeSaveModal"
        class="w-full bg-gray-200 hover:bg-gray-300 text-gray-900 font-medium py-2 rounded-xl transition">
        ЗАКРЫТЬ
      </button>
    </div>
  </div>
  
  <div id="toastNotification" class="fixed bottom-5 right-5 bg-green-600 text-white px-4 py-3 rounded-xl shadow-lg hidden animate-fade-in z-50">
    Плейлист загружен. Каналов: <span id="toastChannelCount" class="font-bold">0</span>
  </div>

  <div id="globalLoader" class="fixed inset-0 flex flex-col items-center justify-center bg-black bg-opacity-50 backdrop-blur-sm hidden z-50">
    <div class="animate-spin rounded-full h-16 w-16 border-b-4 border-white mb-4"></div>
    <p class="text-white text-xl font-semibold">Обработка плейлиста...</p>
  </div>


  <script type="module">
    // =======================================================
    // FIREBASE INITIALIZATION AND AUTH
    // =======================================================
    import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
    import { 
        getAuth, 
        signInAnonymously, 
        signInWithCustomToken, 
        createUserWithEmailAndPassword,
        signInWithEmailAndPassword, // Импортируем функцию для входа
        GoogleAuthProvider,
        signInWithPopup,
        signOut,
        onAuthStateChanged 
    } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";

    // Использование конфигурации, предоставленной пользователем, с учетом глобальных переменных Canvas
    const providedFirebaseConfig = {
      apiKey: "AIzaSyCko3aktIDmXWbsDekdr-dKUscX2fkRpjo",
      authDomain: "read24-7.firebaseapp.com",
      projectId: "read24-7",
      storageBucket: "read24-7.firebasestorage.app",
      messagingSenderId: "966949567813",
      appId: "1:966949567813:web:b12ff4001282d20c29922c",
      measurementId: "G-NVEC5F7S8F"
    };

    const firebaseConfig = JSON.parse(typeof __firebase_config !== 'undefined' ? __firebase_config : JSON.stringify(providedFirebaseConfig));
    const app = initializeApp(firebaseConfig);
    const auth = getAuth(app);
    
    let userId = 'guest';
    let isAnonymousUser = true; // Флаг для отслеживания анонимного статуса

    // Авторизация при запуске
    async function initializeAuth() {
        try {
            if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) {
                await signInWithCustomToken(auth, __initial_auth_token);
                // console.log("Signed in with custom token.");
            } else {
                await signInAnonymously(auth);
                // console.log("Signed in anonymously.");
            }
        } catch (error) {
            console.error("Auth initialization failed:", error.message);
        }
    }

    // ВОССТАНОВЛЕНА ЛОГИКА ДЛЯ АУТЕНТИФИКАЦИИ С ПЕРЕХОДОМ В РЕДАКТОР
    onAuthStateChanged(auth, (user) => {
        const isAuthenticated = user && !user.isAnonymous;
        isAnonymousUser = !isAuthenticated; // Обновляем флаг
        
        // 1. Скрываем/показываем контейнеры
        if (!isAuthenticated) {
            // Гость:
            unauthenticatedMessage.classList.add('hidden'); 
            authButtonContainer.classList.add('hidden');
            
            // Управление кнопками в шапке
            openRegisterModalBtn.classList.remove('hidden'); // Показываем "ВОЙТИ / РЕГИСТРАЦИЯ"
            logoutBtn.classList.add('hidden');
            userId = 'guest';
            
            // ЕСЛИ НЕ АВТОРИЗОВАН, ПОКАЗЫВАЕМ ГЛАВНЫЕ БЛОКИ
            if (mainScreen) mainScreen.classList.remove('hidden'); 
            if (editorScreen) editorScreen.classList.add('hidden');
            if (heroBlock) heroBlock.classList.remove('hidden');
            if (whyUsBlock) whyUsBlock.classList.remove('hidden');
            if (howItWorksBlock) howItWorksBlock.classList.remove('hidden');
            if (comparisonBlock) comparisonBlock.classList.remove('hidden');
            if (faqBlock) faqBlock.classList.remove('hidden');

            // УПРАВЛЕНИЕ КНОПКАМИ В РЕДАКТОРЕ ДЛЯ ГОСТЯ
            if (editorScreen.classList.contains('hidden') === false) {
                 openUploadModalBtn.classList.remove('hidden'); // Загрузка доступна
                 saveBtn.classList.remove('hidden'); // СОХРАНИТЬ ВИДНА
                 guestLogoutBtn.classList.remove('hidden'); // ВЫХОД ВИДЕН
            }
            
        } else {
            // Пользователь вошел:
            // Скрываем главный экран и все его компоненты
            mainScreen.classList.add('hidden'); 
            // Показываем редактор
            editorScreen.classList.remove('hidden');
            
            // Управление кнопками в шапке
            openRegisterModalBtn.classList.add('hidden'); // Скрываем "ВОЙТИ / РЕГИСТРАЦИЯ"
            logoutBtn.classList.remove('hidden'); // Показываем "ВЫЙТИ"
            userId = user.uid; 
            
            // ПОЛНЫЙ ФУНКЦИОНАЛ ДЛЯ АВТОРИЗОВАННОГО ПОЛЬЗОВАТЕЛЯ
            openUploadModalBtn.classList.remove('hidden');
            saveBtn.classList.remove('hidden');
            guestLogoutBtn.classList.add('hidden'); // ВЫХОД СКРЫТ
        }
    });

    initializeAuth();

    // =======================================================
    // REGISTRATION AND LOGOUT FUNCTIONS
    // =======================================================
    
    // УДАЛЕНА handleEmailSignIn
    async function handleEmailSignIn(email, password) {
        // Логика удалена, оставил заглушку для совместимости с кодом
        console.warn("Email sign-in is disabled. Use Google sign-in.");
        showToast("Вход по Email/Паролю отключен. Используйте Google.");
        return false;
    }

    // УДАЛЕНА handleEmailRegistration
    async function handleEmailRegistration(e) {
        e.preventDefault();
        // Логика удалена, оставил заглушку для совместимости с кодом
        console.warn("Email registration is disabled. Use Google sign-in.");
        showToast("Регистрация по Email/Паролю отключена. Используйте Google.");
    }


    async function handleGoogleRegistration() {
        const provider = new GoogleAuthProvider();
        try {
            await signInWithPopup(auth, provider);
            showToast("Вход через Google успешен!");
            registrationModal.classList.add('hidden');
        } catch (error) {
            let errorMessage = "Ошибка входа через Google.";
            // Обработка закрытия окна пользователем (popup-closed-by-user)
            if (error.code === 'auth/popup-closed-by-user') {
                errorMessage = "Окно входа было закрыто.";
            } else {
                errorMessage = `Ошибка: ${error.message}`;
            }
            showToast(errorMessage);
            console.error("Google sign-in error:", error.code, error.message);
        }
    }
    
    async function handleLogout() {
        try {
            await signOut(auth);
            
            // Дополнительная логика сброса UI после onAuthStateChanged
            mainScreen.classList.remove('hidden');
            editorScreen.classList.add('hidden');
            // Прокрутка наверх (к главному экрану)
            window.scrollTo({ top: 0, behavior: 'smooth' });
            
            showToast("Вы успешно вышли из аккаунта.");
        } catch (error) {
            console.error("Logout error:", error.message);
            showToast("Ошибка при выходе.");
        }
    }

    // =======================================================
    // EXISTING SCRIPT LOGIC BELOW
    // =======================================================
    const uploadBtn = document.getElementById('uploadBtn');
    const fileInput = document.getElementById('fileInput');
    const urlInput = document.getElementById('urlInput');
    const loadUrlBtn = document.getElementById('loadUrlBtn');
    const loading = document.getElementById('loading');
    const saveModal = document.getElementById('saveModal');
    const channelCounter = document.getElementById('channelCounter');
    const finalFileName = document.getElementById('finalFileName');
    const downloadBtn = document.getElementById('downloadBtn');
    const closeSaveModal = document.getElementById('closeSaveModal');
    const mainScreen = document.getElementById('mainScreen');
    const editorScreen = document.getElementById('editorScreen');
    const channelList = document.getElementById('channelList');
    const saveBtn = document.getElementById('saveBtn');
    const searchInput = document.getElementById('searchInput');
    const categoryFilter = document.getElementById('categoryFilter'); 
    const removeDuplicatesBtn = document.getElementById('removeDuplicatesBtn'); 
    const dropArea = document.getElementById('dropArea');
    const categorySelect = document.getElementById('categorySelect'); 
    const formatSelect = document.getElementById('formatSelect'); // НОВЫЙ SELECT
    
    const uploadModal = document.getElementById('uploadModal');
    const openUploadModalBtn = document.getElementById('openUploadModalBtn');
    const closeUploadModal = document.getElementById('closeUploadModal');
    const uploadModalBtn = document.getElementById('uploadModalBtn');
    const urlModalInput = document.getElementById('urlModalInput');
    const loadUrlModalBtn = document.getElementById('loadUrlModalBtn');
    const loadingModal = document.getElementById('loadingModal');
    const dropAreaModal = document.getElementById('dropAreaModal'); 
    
    const toastNotification = document.getElementById('toastNotification');
    const toastChannelCount = document.getElementById('toastChannelCount');

    const globalLoader = document.getElementById('globalLoader');

    // ПЕРЕМЕННЫЕ ДЛЯ РЕГИСТРАЦИИ/АУТЕНТИФИКАЦИИ
    const registrationModal = document.getElementById('registrationModal');
    // Используем новую кнопку в шапке
    const openRegisterModalBtnHeader = document.getElementById('openRegisterModalBtnHeader'); 
    const openRegisterModalBtn = openRegisterModalBtnHeader; // Переназначаем, чтобы не менять все обработчики
    // const closeRegisterModal = document.getElementById('closeRegisterModal'); // УДАЛЕНО
    const registerEmailBtn = document.getElementById('registerEmailBtn');
    const registerGoogleBtn = document.getElementById('registerGoogleBtn');
    const registrationFormElement = document.getElementById('registrationFormElement');
    const loginLink = document.getElementById('loginLink'); // Получаем ссылку "Войти"
    
    const unauthenticatedMessage = document.getElementById('unauthenticatedMessage');
    const authButtonContainer = document.getElementById('authButtonContainer');
    
    // Элементы для динамической ссылки
    const dynamicPlaylistLink = document.getElementById('dynamicPlaylistLink');
    const copyLinkBtn = document.getElementById('copyLinkBtn');
    const shortLinkLoader = document.getElementById('shortLinkLoader');
    
    // Элементы для выбора формата
    const formatSelectContainer = document.getElementById('formatSelectContainer');
    const guestFormatMessage = document.getElementById('guestFormatMessage');


    // НОВЫЕ ПЕРЕМЕННЫЕ
    const heroBlock = document.getElementById('heroBlock'); 
    const whyUsBlock = document.getElementById('whyUsBlock'); 
    const howItWorksBlock = document.getElementById('howItWorksBlock'); 
    const comparisonBlock = document.getElementById('comparisonBlock');
    const faqBlock = document.getElementById('faqBlock');
    const knowledgeBaseBlock = document.getElementById('knowledgeBaseBlock'); // Новый блок
    const goToWhyUsBtn = document.getElementById('goToWhyUsBtn'); 
    const startEditingBtn = document.getElementById('startEditingBtn'); 
    const registerNowBtn = document.getElementById('registerNowBtn'); 
    const registerNowCardBtn = document.getElementById('registerNowCardBtn');
    const startNoRegBtn = document.getElementById('startNoRegBtn');
    const dynamicTitlePart = document.getElementById('dynamicTitlePart');
    const menuButton = document.getElementById('menuButton'); // Кнопка гамбургера
    const siteMenu = document.getElementById('siteMenu'); // Мобильное меню
    const knowledgeBaseLink = document.getElementById('knowledgeBaseLink'); // Ссылка на Базу знаний
    const freePlaylistsLink = document.getElementById('freePlaylistsLink'); // Ссылка на Полезные программы
    // *** НОВАЯ КНОПКА ВЫХОДА В РЕДАКТОРЕ ***
    const guestLogoutBtn = document.getElementById('guestLogoutBtn'); 
    // КОНЕЦ НОВЫХ ПЕРЕМЕННЫХ
    
    // НОВАЯ ПЕРЕМЕННАЯ ДЛЯ КРЕСТИКА
    const closeRegisterModalIcon = document.getElementById('closeRegisterModal');

    let originalLines = [];
    let channels = [];
    let allCategories = new Set();
    let excludedCategories = new Set(); 
    let editedContent = ''; // Переменная для хранения контента плейлиста для скачивания
    let categoryChannelCounts = {}; 
    
    const FAVORITE_CATEGORY = 'ИЗБРАННОЕ'; 
    const DISPLAY_FAVORITE_CATEGORY = '✨ИЗБРАННОЕ✨'; 
    
    // ===============================
    // ЛОГИКА ДИНАМИЧЕСКОГО ТЕКСТА
    // =======================================================
    const dynamicPhrases = [
        'вашего удобства', 
        'любых устройств', 
        'быстрого доступа', 
        'идеального порядка', 
        'полного контроля'
    ];
    let currentPhraseIndex = 0;

    function updateDynamicTitle() {
        if (dynamicTitlePart) {
            // 1. Установка нового текста
            dynamicTitlePart.textContent = dynamicPhrases[currentPhraseIndex];
            
            // 2. Сброс анимации (важно для повторного запуска)
            dynamicTitlePart.classList.remove('dynamic-text-animated');
            // Переинициализация анимации через небольшой таймаут
            void dynamicTitlePart.offsetWidth; // Force reflow
            dynamicTitlePart.classList.add('dynamic-text-animated'); 
            
            // 3. Обновление индекса
            currentPhraseIndex = (currentPhraseIndex + 1) % dynamicPhrases.length;
        }
    }

    // Запуск динамического текста только после загрузки всех элементов
    if (dynamicTitlePart) {
        updateDynamicTitle(); // Установка первого значения
        setInterval(updateDynamicTitle, 2000); 
    }
    // =======================================================

    // ===============================
    // ЛОГИКА DRAG AND DROP
    // =======================================================
    const dragDropAreas = [dropArea, dropAreaModal];

    dragDropAreas.forEach(area => {
        if (area) {
            ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
                area.removeEventListener(eventName, preventDefaults, false);
            });
            document.body.removeEventListener('dragover', preventDefaults, false); 
            document.body.removeEventListener('drop', preventDefaults, false);
            ['dragenter', 'dragover'].forEach(eventName => {
                area.removeEventListener(eventName, highlight, false);
            });
            ['dragleave', 'drop'].forEach(eventName => {
                area.removeEventListener(eventName, unhighlight, false);
            });
            area.removeEventListener('drop', handleDrop, false);
        }
    });

    function preventDefaults(e) {
      e.preventDefault();
      e.stopPropagation();
    }

    function highlight(e) {
      // e.currentTarget.classList.add('drag-over'); 
    }

    function unhighlight(e) {
      // e.currentTarget.classList.remove('drag-over'); 
    }

    function handleDrop(e) {
      const dt = e.dataTransfer;
      const files = dt.files;
      if (files.length > 0) {
        handleFiles(files);
      }
    }

    function handleFiles(files) {
        const file = files[0];
        if (!file) return;
        fileInput.files = files;
        fileInput.dispatchEvent(new Event('change'));
    }
    
    // ===============================
    // ФУНКЦИИ УВЕДОМЛЕНИЯ
    // =======================================================
    function showToast(message, count = null) {
        toastChannelCount.classList.add('hidden');
        toastNotification.classList.remove('bg-green-600', 'bg-red-600'); 
        
        if (count !== null) {
            toastChannelCount.textContent = count;
            toastNotification.innerHTML = `Плейлист загружен. Каналов: <span class="font-bold">${count}</span>`;
            toastNotification.classList.add('bg-green-600'); 
        } else {
            toastNotification.textContent = message;
            if (message.includes('Ошибка') || message.includes('Не удалось') || message.includes('Пожалуйста') || message.includes('Email') || message.includes('Пароль') || message.includes('Неверный')) {
                 toastNotification.classList.add('bg-red-600'); 
            } else {
                 toastNotification.classList.add('bg-green-600');
            }
        }
        
        toastNotification.classList.remove('hidden');
        toastNotification.classList.add('animate-fade-in');

        setTimeout(() => {
            toastNotification.classList.add('hidden');
            toastNotification.classList.remove('animate-fade-in');
        }, 3000);
    }
    
    // ===============================
    // ОБРАБОТЧИКИ СОБЫТИЙ
    // =======================================================
    // uploadBtn.addEventListener('click', ...); - удален

    // Обработчик fileInput остается прежним
    fileInput.addEventListener('change', () => {
      const file = fileInput.files[0];
      if (!file) {
          // Если файл не выбран, остаемся на mainScreen
          return;
      }
    
      globalLoader.classList.remove('hidden');
    
      setTimeout(() => {
        const reader = new FileReader();
        reader.onload = function (e) {
          const content = e.target.result;
          processPlaylistContent(content);
        };
        reader.readAsText(file);
      }, 50);
    });

    // loadUrlBtn.addEventListener('click', ...); - удален
    
    openUploadModalBtn.addEventListener('click', () => {
        // Открываем модальное окно для загрузки из редактора
        uploadModal.classList.remove('hidden');
    });

    uploadModalBtn.addEventListener('click', () => {
        // При нажатии кнопки в модалке, вызываем fileInput
        fileInput.click();
    });
    
    loadUrlModalBtn.addEventListener('click', async () => {
      const url = urlModalInput.value.trim();
      // Загрузка через модальное окно
      await loadPlaylistFromUrl(url, loadingModal, loadUrlModalBtn);
    });

    closeUploadModal.addEventListener('click', () => {
        uploadModal.classList.add('hidden');
    });
    
    // ОБРАБОТЧИК КОПИРОВАНИЯ ДИНАМИЧЕСКОЙ ССЫЛКИ
    copyLinkBtn.addEventListener('click', () => {
        const link = dynamicPlaylistLink.value;
        navigator.clipboard.writeText(link).then(() => {
            showToast("Ссылка скопирована в буфер обмена!");
        }).catch(err => {
            console.error('Could not copy text: ', err);
            showToast("Ошибка копирования. Попробуйте вручную.");
        });
    });


    // ОБРАБОТЧИКИ МОДАЛЬНОГО ОКНА РЕГИСТРАЦИИ
    if (openRegisterModalBtn) {
        openRegisterModalBtn.addEventListener('click', () => {
            registrationModal.classList.remove('hidden');
        });
    }

    if (closeRegisterModalIcon) {
        closeRegisterModalIcon.addEventListener('click', () => {
            registrationModal.classList.add('hidden');
        });
    }
    
    // Добавляем обработчик для ссылки "Войти" (Теперь он просто показывает модальное окно Google)
    if (loginLink) {
        loginLink.addEventListener('click', (e) => {
            e.preventDefault();
            handleGoogleRegistration(); // Перенаправляем на Google
        });
    }

    // Подключение функций регистрации и выхода
    // Заглушки, так как формы по Email нет
    if (registrationFormElement) {
        registrationFormElement.addEventListener('submit', handleEmailRegistration);
    }
    
    if (registerGoogleBtn) {
        registerGoogleBtn.addEventListener('click', handleGoogleRegistration);
    }
    
    // ИЗМЕНЕНИЕ: Теперь handleLogout содержит всю логику сброса UI, чтобы гарантировать возврат на главную страницу.
    document.getElementById('logoutBtn').addEventListener('click', handleLogout); 
    
    // *** НОВЫЙ ОБРАБОТЧИК ДЛЯ КНОПКИ ВЫХОДА В РЕДАКТОРЕ ***
    if (guestLogoutBtn) {
        guestLogoutBtn.addEventListener('click', () => {
            // Принудительный сброс UI в состояние "Гость" и переход на главную
            mainScreen.classList.remove('hidden');
            editorScreen.classList.add('hidden');
            // Очищаем список каналов, чтобы не показывать старые данные при следующем входе
            channels = [];
            channelList.innerHTML = '';
            updateCounter(0);
            renderCategoryFilter();
            renderCategorySelect();
            showToast("Выход из режима редактирования.");
            // Прокрутка наверх
            window.scrollTo({ top: 0, behavior: 'smooth' });
        });
    }
    // *** КОНЕЦ НОВОГО ОБРАБОТЧИКА ***
    
    // НОВЫЙ ОБРАБОТЧИК: Кнопка Регистрация в таблице
    if (registerNowBtn) {
        registerNowBtn.addEventListener('click', () => {
             registrationModal.classList.remove('hidden');
        });
    }
    // НОВЫЙ ОБРАБОТЧИК: Кнопка Регистрация в карточке
    if (registerNowCardBtn) {
        registerNowCardBtn.addEventListener('click', () => {
             registrationModal.classList.remove('hidden');
        });
    }
    
    // ДОБАВЛЕНА ЛОГИКА АККОРДЕОНА ДЛЯ FAQ
    window.toggleFaq = function(element) {
        const isExpanded = element.getAttribute('aria-expanded') === 'true';
        
        // Скрываем все остальные открытые
        document.querySelectorAll('.faq-item[aria-expanded="true"]').forEach(item => {
            if (item !== element) {
                item.setAttribute('aria-expanded', 'false');
            }
        });

        // Переключаем текущий элемент
        element.setAttribute('aria-expanded', !isExpanded);
    }
    
    // ЛОГИКА ГАМБУРГЕРА (РАСКРЫТИЕ/СКРЫТИЕ)
    if (menuButton && siteMenu) {
        menuButton.addEventListener('click', () => {
            siteMenu.classList.toggle('open');
        });
        
        // Добавляем закрытие меню при клике по ссылке (только для мобильной версии)
        document.querySelectorAll('#siteMenu .menu-link').forEach(link => {
            link.addEventListener('click', () => {
                if (window.innerWidth <= 640) {
                     siteMenu.classList.remove('open');
                }
            });
        });
    }

    // УДАЛЕНА ЛОГИКА showKnowledgeBase, теперь это просто прокрутка по якорю.
    
    // Обработчик для "Полезные программы" (пока просто прокручивает наверх, так как блока нет)
    if (freePlaylistsLink) {
        freePlaylistsLink.addEventListener('click', (e) => {
            e.preventDefault();
            // Здесь может быть переход на отдельную страницу или открытие модального окна
            console.log("Клик по 'Полезные программы'.");
        });
    }
    
    // *** ИЗМЕНЕННЫЙ ОБРАБОТЧИК: Кнопки "Начать редактирование" ***
    function handleStartEditing() {
        // 1. Показываем модальное окно загрузки
        uploadModal.classList.remove('hidden');

        // 2. Скрываем главный экран и показываем редактор
        mainScreen.classList.add('hidden');
        editorScreen.classList.remove('hidden');
        
        // 3. Настраиваем видимость кнопок в редакторе в зависимости от статуса
        if (isAnonymousUser) {
             // Для гостя: СОХРАНИТЬ ВИДНА, ЗАГРУЗКА ВИДНА, ВЫХОД ВИДЕН
             saveBtn.classList.remove('hidden'); 
             openUploadModalBtn.classList.remove('hidden');
             guestLogoutBtn.classList.remove('hidden'); 
        } else {
             // Для авторизованного: показываем все, ВЫХОД СКРЫТ
             saveBtn.classList.remove('hidden');
             openUploadModalBtn.classList.remove('hidden');
             guestLogoutBtn.classList.add('hidden');
        }
        
        // Прокрутка к редактору
        window.scrollTo({ top: 0, behavior: 'smooth' });
    }

    if (goToWhyUsBtn) {
        goToWhyUsBtn.addEventListener('click', (e) => {
            e.preventDefault(); 
            handleStartEditing(); 
        });
    }
    
    if (startEditingBtn) {
        startEditingBtn.addEventListener('click', (e) => {
            e.preventDefault();
            handleStartEditing(); 
        });
    }
    
    // Обработчик для новой кнопки "Начать редактирование" в карточке "Без регистрации"
    if (startNoRegBtn) {
        startNoRegBtn.addEventListener('click', (e) => {
             e.preventDefault();
             handleStartEditing();
        });
    }
    // *** КОНЕЦ ИЗМЕНЕНИЙ В ОБРАБОТЧИКАХ КНОПОК ***


    async function loadPlaylistFromUrl(url, loadingElement, buttonElement) {
        if (!url) {
            showToast('Пожалуйста, введите ссылку');
            return;
        }
        
        // Гость не может загружать по ссылке (только файлом), так как это требует CORS-прокси
        if (isAnonymousUser) {
            showToast("Загрузка по прямой ссылке доступна только зарегистрированным пользователям.");
            return;
        }

        loadingElement.classList.remove('hidden');
        buttonElement.disabled = true;

        try {
            // Если загрузка идет из модального окна, скрываем его
            if (loadingElement === loadingModal) {
                dropAreaModal.classList.add('hidden');
            }

            const proxyUrl = 'https://corsproxy.io/?' + encodeURIComponent(url);
            const response = await fetch(proxyUrl);
            
            if (!response.ok) {
                throw new Error(`Ошибка HTTP: ${response.status}`);
            }
            
            loadingElement.classList.add('hidden');
            const content = await response.text();

            globalLoader.classList.remove('hidden');

            setTimeout(() => {
                processPlaylistContent(content);
            }, 50);

        } catch (error) {
            console.error('Ошибка загрузки:', error);
            showToast('Не удалось загрузить файл. Возможно, проблема с CORS или файл недоступна.');
            loadingElement.classList.add('hidden');
        } finally {
            buttonElement.disabled = false;
            // Возвращаем видимость дроп-зоны, если она была скрыта
            if (loadingElement === loadingModal) {
                 dropAreaModal.classList.remove('hidden');
            }
        }
    }

    function processPlaylistContent(content) {
        // Мы сохраняем originalLines только для теоретического сохранения других строк,
        // но для редактирования теперь полагаемся на массив channels
        originalLines = content.split('\n'); 
        
        parseChannelsAsync()
            .then(() => {
                globalLoader.classList.add('hidden');
                loadingModal.classList.add('hidden');
                dropAreaModal.classList.remove('hidden');
                uploadModal.classList.add('hidden');

                // Переключаем экраны: основной скрываем, редактор показываем
                mainScreen.classList.add('hidden');
                editorScreen.classList.remove('hidden');
                
                // *** ПРОВЕРКА ДЛЯ УПРАВЛЕНИЯ КНОПКАМИ В РЕДАКТОРЕ ***
                if (isAnonymousUser) {
                    saveBtn.classList.remove('hidden'); 
                    openUploadModalBtn.classList.remove('hidden'); 
                    guestLogoutBtn.classList.remove('hidden');
                } else {
                    saveBtn.classList.remove('hidden');
                    openUploadModalBtn.classList.remove('hidden');
                    guestLogoutBtn.classList.add('hidden');
                }
                // *** КОНЕЦ ПРОВЕРКИ ***
                
                excludedCategories.clear(); 
                renderCategoryFilter();
                renderCategorySelect();
                categorySelect.value = ""; 
                updateCounter(channels.length); 
                renderChannelList();

                // Инициализируем SortableJS после рендеринга
                initializeSortable();

                showToast('Плейлист загружен.', channels.length);
            })
            .catch(error => {
                globalLoader.classList.add('hidden');
                loadingModal.classList.add('hidden');
                dropAreaModal.classList.remove('hidden');
                showToast('Ошибка обработки файла: ' + error.message);
                
                // В случае ошибки возвращаем на главный экран
                mainScreen.classList.remove('hidden');
                editorScreen.classList.add('hidden');
            });
    }
    
    // =======================================================
    // ФУНКЦИЯ ДЛЯ ИНИЦИАЛИЗАЦИИ SORTABLEJS
    // =======================================================
    function initializeSortable() {
        if (!channelList) return;
        
        const isSortableEnabled = !isAnonymousUser; // Гость не может перетаскивать

        // Если Sortable уже был инициализирован, уничтожаем старый экземпляр
        if (channelList.sortableInstance) {
            channelList.sortableInstance.destroy();
        }

        if (isSortableEnabled) {
            channelList.sortableInstance = Sortable.create(channelList, {
                animation: 150,
                group: 'channels',
                handle: '.sortable-channel', // Класс, по которому можно начать перетаскивание
                draggable: '.channel-item',
                onEnd: function (evt) {
                    // evt.oldIndex и evt.newIndex относятся только к отфильтрованному/отображаемому списку.
                    const oldIndex = evt.oldIndex;
                    const newIndex = evt.newIndex;
                    
                    // Получаем массив отображаемых каналов
                    const filteredChannels = getFilteredChannels(searchInput.value, categorySelect.value);

                    if (oldIndex !== newIndex) {
                        // 1. Получаем объект канала, который был перемещен
                        const movedChannel = filteredChannels[oldIndex];
                        
                        // 2. Находим текущий индекс этого канала в основном массиве `channels`
                        const oldChannelIndexInMainArray = channels.findIndex(c => c === movedChannel);

                        if (oldChannelIndexInMainArray === -1) {
                             // Если канал не найден в основном массиве, что-то пошло не так.
                             return; 
                        }
                        
                        // 3. Вырезаем его из основного массива
                        channels.splice(oldChannelIndexInMainArray, 1);

                        // 4. Определяем канал, после которого (или перед которым) нужно вставить
                        let targetChannel = filteredChannels[newIndex];
                        let newChannelIndexInMainArray;
                        
                        if (targetChannel) {
                            // Находим индекс цели в основном массиве
                            const targetIndexInMainArray = channels.findIndex(c => c === targetChannel);
                            
                            // Если переместили вниз, вставляем после target, иначе - перед
                            newChannelIndexInMainArray = targetIndexInMainArray;
                        } else if (newIndex > oldIndex && filteredChannels.length > 0) {
                            // Если перетащено в самый конец отображаемого списка
                            newChannelIndexInMainArray = channels.length;
                        } else {
                            // Если список пуст или перетащено на 0-ю позицию
                             newChannelIndexInMainArray = 0;
                        }
                        
                        // 5. Вставляем канал обратно в основной массив по новому индексу
                        channels.splice(newChannelIndexInMainArray, 0, movedChannel);
                        
                        // 6. Перерендеринг списка, чтобы убедиться, что все каналы (включая скрытые) обновлены
                        renderChannelList(searchInput.value);
                        initializeSortable(); // Переинициализация Sortable после рендеринга
                        showToast(`Порядок каналов обновлен.`);
                    }
                }
            });
        }
    }

    function parseChannelsAsync() {
        return new Promise((resolve, reject) => {
            try {
                channels = [];
                allCategories.clear();
                categoryChannelCounts = {};

                const lines = originalLines;
                const totalLines = lines.length;
                let currentIndex = 0;
                const chunkSize = 1000;

                function processChunk() {
                    const limit = Math.min(currentIndex + chunkSize, totalLines);

                    for (let i = currentIndex; i < limit; i++) {
                        const line = lines[i].trim();

                        if (line.startsWith('#EXTINF')) {
                            const extinf = line;
                            const nameMatch = extinf.match(/,(.*)$/);
                            let name = nameMatch ? nameMatch[1].trim() : 'Неизвестный канал';
                            
                            let category = 'Без категории';
                            const groupTitleMatch = extinf.match(/group-title="([^"]*)"/i);
                            if (groupTitleMatch) {
                                category = groupTitleMatch[1].trim();
                            }

                            let url = '';
                            let extgrp = '';
                            let urlIndex = i + 1;

                            while (urlIndex < lines.length) {
                                const nextLine = lines[urlIndex].trim();
                                if (nextLine.startsWith('#EXTGRP:')) {
                                    if (category === 'Без категории' || category === '') {
                                        category = nextLine.substring(8).trim();
                                    }
                                    extgrp = nextLine;
                                } else if (nextLine && !nextLine.startsWith('#')) {
                                    url = nextLine;
                                    break;
                                } else if (nextLine.startsWith('#EXTINF')) {
                                    break; 
                                }
                                urlIndex++;
                            }

                            if (url) {
                                channels.push({
                                    name, extinf, extgrp, url,
                                    startIndex: i,
                                    endIndex: urlIndex,
                                    category,
                                    isFavorite: false,
                                });
                                allCategories.add(category);
                                categoryChannelCounts[category] = (categoryChannelCounts[category] || 0) + 1;
                                i = urlIndex;
                            }
                        }
                    }

                    currentIndex = limit;

                    if (currentIndex < totalLines) {
                        setTimeout(processChunk, 0);
                    } else {
                        // УБРАНА ПЕРВОНАЧАЛЬНАЯ СОРТИРОВКА ПО ИМЕНИ.
                        resolve();
                    }
                }

                processChunk();
            } catch (error) {
                reject(error);
            }
        });
    }
    
    // Вспомогательная функция, чтобы не дублировать логику фильтрации
    function getFilteredChannels(filter = '', selectedCategory = '') {
        let filteredChannels = channels;

        filteredChannels = filteredChannels.filter(entry => !excludedCategories.has(entry.category));

        if (selectedCategory === FAVORITE_CATEGORY) {
            filteredChannels = filteredChannels.filter(entry => entry.isFavorite);
        } else if (excludedCategories.has(FAVORITE_CATEGORY)) {
            filteredChannels = filteredChannels.filter(entry => !entry.isFavorite);
        }

        filteredChannels = filteredChannels
            .filter(entry => entry.name.toLowerCase().includes(filter.toLowerCase()))
            .filter(entry => !selectedCategory || selectedCategory === FAVORITE_CATEGORY || entry.category === selectedCategory);
            
        return filteredChannels;
    }

    function getFavoriteCount() { 
        return channels.filter(c => c.isFavorite).length;
    }

    function renderCategoryFilter() {
      categoryFilter.innerHTML = '';
      const sortedCategories = Array.from(allCategories).sort();

      const favoriteCount = getFavoriteCount(); 
      
      if (favoriteCount > 0 || excludedCategories.has(FAVORITE_CATEGORY)) {
          sortedCategories.unshift(FAVORITE_CATEGORY);
          categoryChannelCounts[FAVORITE_CATEGORY] = favoriteCount;
      }

      sortedCategories.forEach(category => {
        const container = document.createElement('label');
        container.className = 'flex items-center space-x-2 bg-white px-3 py-1 rounded-full shadow-sm cursor-pointer hover:bg-gray-100 transition text-sm';

        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.className = 'form-checkbox h-4 w-4 text-black rounded border-gray-300 focus:ring-0';
        checkbox.value = category;
        checkbox.checked = excludedCategories.has(category);
        
        checkbox.addEventListener('change', (e) => {
          if (e.target.checked) {
            excludedCategories.add(category);
          } else {
            excludedCategories.delete(category);
          }
          renderChannelList(searchInput.value); 
          initializeSortable(); // Переинициализация Sortable после смены фильтра
        });

        const span = document.createElement('span');
        const count = categoryChannelCounts[category] || 0;
        span.className = 'text-gray-800 truncate max-w-[150px]';
        span.innerHTML = `${category} (<span class="text-red-600 font-bold">${count}</span>)`;

        container.appendChild(checkbox);
        container.appendChild(span);
        categoryFilter.appendChild(container);
      });
    }
    
    function renderCategorySelect() {
        categorySelect.innerHTML = '<option value="">Все категории</option>';
        const sortedCategories = Array.from(allCategories).sort();
        
        const favoriteCount = getFavoriteCount(); 
        
        if (favoriteCount > 0) { 
             sortedCategories.unshift(FAVORITE_CATEGORY);
             categoryChannelCounts[FAVORITE_CATEGORY] = favoriteCount;
        }

        sortedCategories.forEach(category => {
            const option = document.createElement('option');
            option.value = category;
            const count = categoryChannelCounts[category] || 0;
            option.textContent = `${category} (${count})`;
            categorySelect.appendChild(option);
        });
    }

    categorySelect.addEventListener('change', () => {
        renderChannelList(searchInput.value);
        initializeSortable(); // Переинициализация Sortable после смены фильтра
    });

    function downloadSingleChannel(entry) {
        
      if (isAnonymousUser && saveModal.classList.contains('hidden') === false) {
           saveModal.classList.add('hidden'); // Скрываем модалку сохранения, если она открыта
      }
        
      let playlistContent = `#EXTM3U\n`;
      
      let extinfLine = entry.extinf;
      
      playlistContent += `${extinfLine}\n`;
      
      if (entry.extgrp) {
        playlistContent += `${entry.extgrp}\n`;
      }
      playlistContent += `${entry.url}`;

      const blob = new Blob([playlistContent], { type: 'text/plain;charset=utf-8' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `${entry.name.replace(/[^a-zA-Z0-9а-яА-Я]/g, '_')}.m3u`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }

    function toggleFavorite(entry) {
        // Гость не может использовать Избранное, так как нет сохранения
        if (isAnonymousUser) {
             showToast("Функция 'Избранное' доступна только зарегистрированным пользователям.");
             registrationModal.classList.remove('hidden');
             return;
        }

        entry.isFavorite = !entry.isFavorite; 

        renderCategoryFilter();
        renderCategorySelect();
        renderChannelList(searchInput.value);
        initializeSortable(); // Переинициализация Sortable после изменения избранного
        
        const action = entry.isFavorite ? 'добавлен в' : 'удален из';
        showToast(`Канал "${entry.name}" ${action} избранного.`);
    }
    
    function renderChannelList(filter = '') {
      channelList.innerHTML = '';
      
      const isMobile = window.matchMedia('(max-width: 640px)').matches;
      const downloadButtonText = isMobile ? 'Скачать' : 'Скачать канал';
      
      const selectedCategory = categorySelect.value; 
      
      let filteredChannels = getFilteredChannels(filter, selectedCategory);

      updateCounter(filteredChannels.length); 
        
      filteredChannels.forEach((entry, index) => {
          const item = document.createElement('div');
          // Если гость, то убираем класс sortable-channel
          const draggableClass = isAnonymousUser ? '' : 'sortable-channel';
          item.className = `channel-item flex items-center justify-between bg-gray-100 px-4 py-2 rounded-xl shadow ${draggableClass}`; 
          item.dataset.channelUrl = entry.url; // Используем URL как уникальный (хоть и не всегда) идентификатор
          item.dataset.channelName = entry.name; // Добавляем имя для более надежной идентификации
          
          // *** НУМЕРАЦИЯ КАНАЛА ***
          const contentWrapper = document.createElement('div');
          contentWrapper.className = 'channel-item-content';

          const number = document.createElement('span');
          number.className = 'channel-number';
          number.textContent = index + 1; // Нумерация с 1
          
          const name = document.createElement('span');
          // Убраны классы max-w-[60%] md:max-w-[70%], так как стили truncate теперь в CSS
          name.className = 'channel-name text-black font-medium'; 
          name.textContent = entry.name;

          contentWrapper.appendChild(number);
          contentWrapper.appendChild(name);
          // *** КОНЕЦ НУМЕРАЦИИ КАНАЛА ***

          const favBtn = document.createElement('button');
          const starColor = entry.isFavorite ? 'text-yellow-500 hover:text-yellow-400' : 'text-gray-400 hover:text-yellow-500';
          favBtn.className = `channel-favorite-btn ${starColor} font-semibold text-xl px-2 py-1 transition flex-shrink-0`;
          favBtn.innerHTML = '★'; 
          favBtn.title = entry.isFavorite ? 'Удалить из избранного' : 'Добавить в избранное';
          favBtn.onclick = () => toggleFavorite(entry);
          
          // Скрываем кнопку избранного для гостя
          if (isAnonymousUser) {
             favBtn.classList.add('hidden');
          }


          const downloadBtn = document.createElement('button');
          downloadBtn.className = 'channel-download-btn bg-green-600 hover:bg-green-500 text-white font-semibold text-sm px-3 py-1 rounded-lg transition';
          downloadBtn.textContent = downloadButtonText;
          downloadBtn.onclick = () => downloadSingleChannel(entry);
          
          // ПОКАЗЫВАЕМ КНОПКУ "СКАЧАТЬ КАНАЛ" ТОЛЬКО ДЛЯ АВТОРИЗОВАННЫХ
          if (isAnonymousUser) {
              downloadBtn.classList.add('hidden');
          } else {
              downloadBtn.classList.remove('hidden');
          }


          const delBtn = document.createElement('button');
          delBtn.className = 'channel-delete-btn text-red-600 hover:text-red-500 font-semibold text-sm';
          delBtn.textContent = 'Удалить';
          
          // **********************************************
          // ИСПРАВЛЕНИЕ: НАДЕЖНОЕ УДАЛЕНИЕ КАНАЛА ИЗ МАССИВА
          // **********************************************
          delBtn.onclick = () => {
            const indexToDelete = channels.findIndex(c => c === entry);
            
            if (indexToDelete !== -1) {
              // Удаляем канал из основного массива channels
              channels.splice(indexToDelete, 1); 
              
              // Обновляем все UI-элементы
              renderCategoryFilter();
              renderCategorySelect(); 
              renderChannelList(searchInput.value); 
              initializeSortable(); 
              showToast(`Канал "${entry.name}" удален.`);
            }
            
            // Важно: originalLines больше не изменяется напрямую при удалении канала.
            // Он будет пересоздан при сохранении плейлиста.
          };
          // **********************************************

          const buttonContainer = document.createElement('div');
          buttonContainer.className = 'channel-buttons-container flex items-center gap-2 flex-shrink-0';
          
          // Добавляем кнопки в контейнер, учитывая их видимость
          buttonContainer.appendChild(favBtn); 
          buttonContainer.appendChild(downloadBtn);
          buttonContainer.appendChild(delBtn);

          item.appendChild(contentWrapper); // Добавляем обертку с нумерацией и именем
          item.appendChild(buttonContainer);
          channelList.appendChild(item);
        });
    }
    
    // Обновляем parseChannelsSync, чтобы она не сортировала, если это не удаление.
    function parseChannelsSync(maintainOrder = false) {
      // 1. Сохраняем текущие статусы избранного перед очисткой
      const tempFavoriteMap = {};
      channels.forEach(c => {
        if (c.isFavorite) {
            tempFavoriteMap[c.url + c.name] = true; 
        }
      });
        
      channels = [];
      allCategories.clear();
      categoryChannelCounts = {};
      
      // Итерируемся по originalLines, чтобы восстановить channels и category data
      // ВНИМАНИЕ: Эта функция должна использоваться только для обработки дубликатов, 
      // где originalLines были изменены, или при первоначальной загрузке.
      // Для удаления одиночных каналов используем более надежную логику в renderChannelList.
      for (let i = 0; i < originalLines.length; i++) {
        const line = originalLines[i].trim();
        if (line.startsWith('#EXTINF')) {
          const extinf = line;
          const nameMatch = extinf.match(/,(.*)$/);
          let name = nameMatch ? nameMatch[1].trim() : 'Неизвестный канал';
          let category = 'Без категории';
          const groupTitleMatch = extinf.match(/group-title="([^"]*)"/i);
          if (groupTitleMatch) {
            category = groupTitleMatch[1].trim();
          }
          let url = '';
          let extgrp = '';
          let urlIndex = i + 1;
          while (urlIndex < originalLines.length) {
            const nextLine = originalLines[urlIndex].trim(); // ИСПРАВЛЕНО: было lines[urlIndex].trim()
            if (nextLine.startsWith('#EXTGRP:')) {
              if (category === 'Без категории' || category === '') {
                category = nextLine.substring(8).trim();
              }
              extgrp = nextLine;
            } else if (nextLine && !nextLine.startsWith('#')) {
              url = nextLine;
              break;
            } else if (nextLine.startsWith('#EXTINF')) {
              break;
            }
            urlIndex++;
          }
          if (url) {
            const key = url + name;
            const isFav = tempFavoriteMap[key] || false; 

            channels.push({
              name, extinf, extgrp, url,
              startIndex: i,
              endIndex: urlIndex,
              category,
              isFavorite: isFav, 
            });
            allCategories.add(category);
            categoryChannelCounts[category] = (categoryChannelCounts[category] || 0) + 1;
            i = urlIndex;
          }
        }
      }
    }


    function updateCounter(filteredCount = null) {
      if (filteredCount !== null) {
          channelCounter.textContent = filteredCount;
      } else {
          let remainingChannels = channels.filter(entry => !excludedCategories.has(entry.category));
          
          if (excludedCategories.has(FAVORITE_CATEGORY)) { 
              remainingChannels = remainingChannels.filter(entry => !entry.isFavorite);
          }
          
          channelCounter.textContent = remainingChannels.length;
      }
    }

    searchInput.addEventListener('input', () => {
      renderChannelList(searchInput.value);
      initializeSortable();
    });

    function removeDuplicates() {
        const uniqueNames = new Set();
        // ВАЖНО: При удалении дубликатов мы все еще должны модифицировать originalLines
        // чтобы сохранить все не-EXTINF строки (комментарии, #EXTM3U и т.д.)
        const indicesToRemove = []; // Сохраняем индексы в массиве channels для удаления
        let removedCount = 0;

        // Идем с конца, чтобы сохранить первый найденный дубликат
        for (let i = channels.length - 1; i >= 0; i--) {
            const channel = channels[i];
            const nameKey = channel.name.trim().toLowerCase(); 

            if (uniqueNames.has(nameKey)) {
                indicesToRemove.push(i); // Добавляем индекс в channels
                removedCount++;
            } else {
                uniqueNames.add(nameKey);
            }
        }
        
        // Удаляем каналы из массива channels (с конца)
        indicesToRemove.sort((a, b) => b - a);
        indicesToRemove.forEach(index => {
            channels.splice(index, 1);
        });
        
        // Теперь, когда channels обновлен, перестраиваем originalLines (просто как массив)
        // Для простоты мы не восстанавливаем старые комментарии, а только EXTINF/URL
        // Если вы хотите сохранить все не-EXTINF строки, эта функция должна быть сложнее.
        // Но для цели "Удалить дубликаты" лучше просто перестроить.
        
        if (removedCount > 0) {
            // Перепарсинг в этом случае не нужен, так как каналы уже удалены.
            // Нужно просто обновить UI.
            renderCategoryFilter();
            renderCategorySelect(); 
            renderChannelList(searchInput.value); 
            initializeSortable(); 
            showToast(`Удалено ${removedCount} дубликатов каналов.`); 
        } else {
            showToast('Дубликаты каналов не найдены.'); 
        }
    }
    
    removeDuplicatesBtn.addEventListener('click', removeDuplicates);
    
    // =======================================================
    // ФУНКЦИИ СЕРВЕРНОГО СОХРАНЕНИЯ И СОКРАЩЕНИЯ ССЫЛКИ
    // =======================================================

    async function shortenDynamicLink(longUrl) {
        const apiUrl = `https://is.gd/create.php?format=json&url=${encodeURIComponent(longUrl)}`;
        
        try {
            const response = await fetch(apiUrl);
            const data = await response.json();
            
            if (data.shorturl) {
                return data.shorturl;
            } else {
                console.error('is.gd Error:', data.errormessage || 'Unknown error');
                showToast(`Ошибка сокращения ссылки: ${data.errormessage || 'Сбой API.'}`);
                return longUrl; // Вернуть длинную ссылку в случае ошибки
            }
        } catch (error) {
            console.error('Fetch Error:', error);
            showToast('⚠️ Ошибка соединения с is.gd.');
            return longUrl; // Вернуть длинную ссылку в случае сбоя сети
        }
    }

    async function uploadPlaylistToGitHub(content, count, persistentUserId) {
        // Проверка: теперь аутентификация обязательна
        if (auth.currentUser?.isAnonymous) {
            console.error("Attempted server upload as guest. This should not happen.");
            showToast("Ошибка: Сохранение на сервере требует входа.");
            return; 
        }

        const uploadUrl = '/.netlify/functions/save-playlist'; 
        
        try {
            // Файл будет сохранен под этим постоянным именем, обеспечивая динамическую ссылку.
            const permanentFilename = `playlist_${persistentUserId}_latest.m3u`;
            
            const response = await fetch(uploadUrl, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    filename: permanentFilename, // Передаем постоянное имя
                    fileContent: content, 
                    userId: userId,
                }),
            });
            
            if (!response.ok) {
                const errorData = await response.json();
                throw new Error(errorData.details || errorData.error || 'Unknown API Error');
            }
            
            // Если запрос успешен, то плейлист обновлен по динамической ссылке
            // showToast(`Плейлист обновлен на сервере. (${count} каналов)`); // УДАЛЕНО УВЕДОМЛЕНИЕ
            
        } catch (error) {
            console.error('Ошибка сохранения:', error);
            showToast(`Ошибка сохранения на сервере: ${error.message}`);
        }
    }

    // =======================================================
    // ФОРМИРОВАНИЕ КОНТЕНТА ПЛЕЙЛИСТА (ОБНОВЛЕНО ДЛЯ TXT)
    // =======================================================
    function generatePlaylistContent(format) {
        const includedChannels = channels.filter(entry => {
            const isNormalCategoryExcluded = excludedCategories.has(entry.category);
            const isFavoriteCategoryExcluded = excludedCategories.has(FAVORITE_CATEGORY);
            const isFavorite = entry.isFavorite;

            if (isFavorite) {
                return !isFavoriteCategoryExcluded;
            }
            
            return !isNormalCategoryExcluded;
        });
        
        let modifiedLines = [];
        
        // Добавляем заголовок #EXTM3U, если это не TXT
        if (format !== 'txt') {
             modifiedLines.push(`#EXTM3U`);
        }

        const favoriteChannels = includedChannels.filter(c => c.isFavorite);
        
        // Добавление избранного (только для авторизованных)
        if (favoriteChannels.length > 0 && !isAnonymousUser) { 
            if (format !== 'txt') { // Добавляем группировку, если это не TXT
               modifiedLines.push(`#EXTGRP:${DISPLAY_FAVORITE_CATEGORY}`); 
            }
            
            favoriteChannels.forEach(entry => {
                let favExtinf = entry.extinf;
                
                // Форматирование EXTINF для избранного, если это не TXT
                if (format !== 'txt') {
                    favExtinf = favExtinf.replace(/group-title="([^"]*)"/i, `group-title="${DISPLAY_FAVORITE_CATEGORY}"`);
                    if (!favExtinf.includes('group-title=')) {
                        favExtinf = favExtinf.replace(/,(.*)$/, ` group-title="${DISPLAY_FAVORITE_CATEGORY}",$1`);
                    }
                    modifiedLines.push(favExtinf);
                } else {
                     // Для TXT просто добавляем оригинальные теги
                     if (entry.extinf) modifiedLines.push(entry.extinf);
                     if (entry.extgrp) modifiedLines.push(entry.extgrp);
                }
                
                modifiedLines.push(entry.url);
            });
            
            if (format !== 'txt') {
                modifiedLines.push('');
            } else {
                // Если TXT, добавляем разделитель после группы избранного (если она есть)
                if (favoriteChannels.length > 0) modifiedLines.push('');
            }
        }
        
        const groupedChannels = {};
        includedChannels.forEach(entry => {
            if (entry.isFavorite && !isAnonymousUser) return;
            
            const cat = entry.category || 'Без категории';
            if (!groupedChannels[cat]) {
                groupedChannels[cat] = [];
            }
            groupedChannels[cat].push(entry);
        });
        
        const sortedCategories = Object.keys(groupedChannels).filter(cat => cat !== FAVORITE_CATEGORY).sort();
        
        sortedCategories.forEach(cat => {
            // Добавляем EXTGRP
            if (cat !== 'Без категории') {
                // Если это не TXT, используем EXTGRP для группировки
                if (format !== 'txt') {
                    modifiedLines.push(`#EXTGRP:${cat}`);
                } else {
                     // Для TXT добавляем EXTGRP (если он не был в самом EXTINF)
                     // Примечание: Для TXT мы добавляем EXTGRP только для категории.
                     modifiedLines.push(`#EXTGRP:${cat}`);
                }
            }

            groupedChannels[cat].forEach(entry => {
                // Добавляем EXTINF
                if (entry.extinf) {
                    modifiedLines.push(entry.extinf);
                }
                // Для TXT добавляем EXTGRP (если он был в оригинале и не был добавлен выше)
                if (format === 'txt' && entry.extgrp && cat === 'Без категории') {
                    // Если у канала есть extgrp, но он в 'Без категории', мы его добавляем.
                    modifiedLines.push(entry.extgrp);
                }
                
                // Добавляем URL
                modifiedLines.push(entry.url);
            });
            
            // Добавляем пустую строку после категории (только если это не самый конец)
            // (Простой способ избежать двойной пустой строки в конце)
             if (format !== 'txt' || cat !== sortedCategories[sortedCategories.length - 1]) {
                 modifiedLines.push('');
             }
        });
        
        // Удаляем последнюю пустую строку, если она есть
        if (modifiedLines.length > 0 && modifiedLines[modifiedLines.length - 1] === '') {
            modifiedLines.pop();
        }
        
        return modifiedLines.join('\n');
    }


    // =======================================================
    // ОБНОВЛЕННЫЙ ОБРАБОТЧИК КНОПКИ СОХРАНИТЬ (АСИНХРОННЫЙ)
    // =======================================================
    saveBtn.addEventListener('click', async () => {
      
      // 1. Формирование контента для сервера (всегда M3U8)
      const contentForServer = generatePlaylistContent('m3u8');
      editedContent = contentForServer;
      
      // Определяем количество каналов
      const finalChannelCount = channels.filter(c => !excludedCategories.has(c.category)).length; 

      // 2. УПРАВЛЕНИЕ ДЛЯ ГОСТЯ
      if (isAnonymousUser) {
          finalFileName.textContent = `ФАЙЛ ${finalChannelCount} КАНАЛОВ`;
          // Скрываем контейнер динамической ссылки и выбор формата
          document.getElementById('dynamicLinkContainer').classList.add('hidden');
          formatSelectContainer.classList.add('hidden');
          // guestFormatMessage.classList.remove('hidden'); // УДАЛЕНО: надпись о формате M3U
          
          saveModal.classList.remove('hidden');
          return;
      }
      
      // 3. ЛОГИКА ДЛЯ АВТОРИЗОВАННОГО ПОЛЬЗОВАТЕЛЯ 
      const persistentUserId = userId; 
      const longDynamicLink = `https://read24.netlify.app/api/playlist/${persistentUserId}/latest.m3u`;
      
      // Показываем элементы для авторизованного пользователя
      document.getElementById('dynamicLinkContainer').classList.remove('hidden');
      formatSelectContainer.classList.remove('hidden');
      guestFormatMessage.classList.add('hidden');
      
      finalFileName.textContent = `ФАЙЛ ${finalChannelCount} КАНАЛОВ`;
      dynamicPlaylistLink.value = "Сокращаю ссылку...";
      shortLinkLoader.classList.remove('hidden');
      document.getElementById('formatSelect').value = 'm3u'; // Сброс формата
      saveModal.classList.remove('hidden');
      
      // Асинхронно сокращаем ссылку
      const shortLink = await shortenDynamicLink(longDynamicLink);
      
      // 4. Обновляем UI и запускаем сохранение на сервере
      shortLinkLoader.classList.add('hidden');
      dynamicPlaylistLink.value = shortLink;
      
      // Запускаем сохранение на GitHub в фоне (включает ожидание)
      uploadPlaylistToGitHub(contentForServer, finalChannelCount, persistentUserId); 
    });

    // =======================================================
    // ОБНОВЛЕННЫЙ ОБРАБОТЧИК ЛОКАЛЬНОГО СКАЧИВАНИЯ
    // =======================================================
    downloadBtn.addEventListener('click', () => {
        
      // Гость скачивает только в M3U, авторизованный выбирает
      const selectedFormat = isAnonymousUser ? 'm3u' : formatSelect.value;
      const contentToDownload = generatePlaylistContent(selectedFormat);

      // Определение MIME-типа и расширения файла
      let mimeType = 'text/plain;charset=utf-8';
      let fileExtension = selectedFormat;
      if (selectedFormat === 'm3u') {
          mimeType = 'application/x-mpegurl;charset=utf-8';
      } else if (selectedFormat === 'm3u8') {
          mimeType = 'application/x-mpegurl;charset=utf-8';
      } else if (selectedFormat === 'txt') {
          mimeType = 'text/plain;charset=utf-8';
      }


      const blob = new Blob([contentToDownload], { type: mimeType });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      
      // Считаем каналы для имени файла
      const remainingChannels = channels.filter(entry => {
        const isNormalCategoryExcluded = excludedCategories.has(entry.category);
        const isFavoriteCategoryExcluded = excludedCategories.has(FAVORITE_CATEGORY);
        const isFavorite = entry.isFavorite;

        if (isFavorite) {
            return !isFavoriteCategoryExcluded;
        }
        
        return !isNormalCategoryExcluded;
      });
      
      const remainingCount = remainingChannels.length; 
      // Имя файла для локального скачивания
      a.download = `playlist_${remainingCount}.${fileExtension}`; 
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    });

    closeSaveModal.addEventListener('click', () => {
      saveModal.classList.add('hidden');
      // При закрытии модалки восстанавливаем видимость динамической ссылки для авторизованных
      if (!isAnonymousUser) {
           document.getElementById('dynamicLinkContainer').classList.remove('hidden');
      }
    });
    
  </script>
</body>
</html>